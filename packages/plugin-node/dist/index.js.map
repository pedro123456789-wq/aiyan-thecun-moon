{"version":3,"sources":["../src/services/browser.ts","../src/services/image.ts","../src/services/llama.ts","../src/services/pdf.ts","../src/services/speech.ts","../src/services/audioUtils.ts","../src/enviroment.ts","../src/services/transcription.ts","../src/services/video.ts","../src/index.ts"],"sourcesContent":["import { generateText, IBrowserService, trimTokens } from \"@ai16z/eliza\";\nimport { parseJSONObjectFromText } from \"@ai16z/eliza\";\nimport { Service } from \"@ai16z/eliza\";\nimport { settings } from \"@ai16z/eliza\";\nimport { IAgentRuntime, ModelClass, ServiceType } from \"@ai16z/eliza\";\nimport { stringToUuid } from \"@ai16z/eliza\";\nimport { PlaywrightBlocker } from \"@cliqz/adblocker-playwright\";\nimport CaptchaSolver from \"capsolver-npm\";\nimport { Browser, BrowserContext, chromium, Page } from \"playwright\";\n\nasync function generateSummary(\n    runtime: IAgentRuntime,\n    text: string\n): Promise<{ title: string; description: string }> {\n    // make sure text is under 128k characters\n    text = trimTokens(text, 100000, \"gpt-4o-mini\"); // TODO: clean this up\n\n    const prompt = `Please generate a concise summary for the following text:\n  \n  Text: \"\"\"\n  ${text}\n  \"\"\"\n  \n  Respond with a JSON object in the following format:\n  \\`\\`\\`json\n  {\n    \"title\": \"Generated Title\",\n    \"summary\": \"Generated summary and/or description of the text\"\n  }\n  \\`\\`\\``;\n\n    const response = await generateText({\n        runtime,\n        context: prompt,\n        modelClass: ModelClass.SMALL,\n    });\n\n    const parsedResponse = parseJSONObjectFromText(response);\n\n    if (parsedResponse) {\n        return {\n            title: parsedResponse.title,\n            description: parsedResponse.summary,\n        };\n    }\n\n    return {\n        title: \"\",\n        description: \"\",\n    };\n}\n\ntype PageContent = {\n    title: string;\n    description: string;\n    bodyContent: string;\n};\n\nexport class BrowserService extends Service implements IBrowserService {\n    private browser: Browser | undefined;\n    private context: BrowserContext | undefined;\n    private blocker: PlaywrightBlocker | undefined;\n    private captchaSolver: CaptchaSolver;\n    private cacheKey = \"content/browser\";\n\n    private queue: string[] = [];\n    private processing: boolean = false;\n\n    static serviceType: ServiceType = ServiceType.BROWSER;\n\n    static register(runtime: IAgentRuntime): IAgentRuntime {\n        // since we are lazy loading, do nothing\n        return runtime;\n    }\n\n    getInstance(): IBrowserService {\n        return BrowserService.getInstance();\n    }\n\n    constructor() {\n        super();\n        this.browser = undefined;\n        this.context = undefined;\n        this.blocker = undefined;\n        this.captchaSolver = new CaptchaSolver(\n            settings.CAPSOLVER_API_KEY || \"\"\n        );\n    }\n\n    async initialize() {\n        if (!this.browser) {\n            this.browser = await chromium.launch({\n                args: [\"--no-sandbox\", \"--disable-setuid-sandbox\"],\n            });\n\n            this.context = await this.browser.newContext({\n                userAgent:\n                    \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36\",\n            });\n\n            this.blocker =\n                await PlaywrightBlocker.fromPrebuiltAdsAndTracking(fetch);\n        }\n    }\n\n    async closeBrowser() {\n        if (this.context) {\n            await this.context.close();\n            this.context = undefined;\n        }\n        if (this.browser) {\n            await this.browser.close();\n            this.browser = undefined;\n        }\n    }\n\n    async getPageContent(\n        url: string,\n        runtime: IAgentRuntime\n    ): Promise<PageContent> {\n        await this.initialize();\n        this.queue.push(url);\n        this.processQueue(runtime);\n\n        return new Promise((resolve, reject) => {\n            const checkQueue = async () => {\n                const index = this.queue.indexOf(url);\n                if (index !== -1) {\n                    setTimeout(checkQueue, 100);\n                } else {\n                    try {\n                        const result = await this.fetchPageContent(\n                            url,\n                            runtime\n                        );\n                        resolve(result);\n                    } catch (error) {\n                        reject(error);\n                    }\n                }\n            };\n            checkQueue();\n        });\n    }\n\n    private getCacheKey(url: string): string {\n        return stringToUuid(url);\n    }\n\n    private async processQueue(runtime: IAgentRuntime): Promise<void> {\n        if (this.processing || this.queue.length === 0) {\n            return;\n        }\n\n        this.processing = true;\n\n        while (this.queue.length > 0) {\n            const url = this.queue.shift();\n            await this.fetchPageContent(url, runtime);\n        }\n\n        this.processing = false;\n    }\n\n    private async fetchPageContent(\n        url: string,\n        runtime: IAgentRuntime\n    ): Promise<PageContent> {\n        const cacheKey = this.getCacheKey(url);\n        const cached = await runtime.cacheManager.get<{\n            url: string;\n            content: PageContent;\n        }>(`${this.cacheKey}/${cacheKey}`);\n\n        if (cached) {\n            return cached.content;\n        }\n\n        let page: Page | undefined;\n\n        try {\n            if (!this.context) {\n                console.log(\n                    \"Browser context not initialized. Call initialize() first.\"\n                );\n            }\n\n            page = await this.context.newPage();\n\n            // Enable stealth mode\n            await page.setExtraHTTPHeaders({\n                \"Accept-Language\": \"en-US,en;q=0.9\",\n            });\n\n            // Apply ad blocker\n            if (this.blocker) {\n                await this.blocker.enableBlockingInPage(page);\n            }\n\n            const response = await page.goto(url, { waitUntil: \"networkidle\" });\n\n            if (!response) {\n                console.log(\"Failed to load the page\");\n            }\n\n            if (response.status() === 403 || response.status() === 404) {\n                return await this.tryAlternativeSources(url, runtime);\n            }\n\n            // Check for CAPTCHA\n            const captchaDetected = await this.detectCaptcha(page);\n            if (captchaDetected) {\n                await this.solveCaptcha(page, url);\n            }\n            const title = await page.evaluate(() => document.title);\n            const bodyContent = await page.evaluate(\n                () => document.body.innerText\n            );\n            const { description } = await generateSummary(\n                runtime,\n                title + \"\\n\" + bodyContent\n            );\n            const content = { title, description, bodyContent };\n            await runtime.cacheManager.set(`${this.cacheKey}/${cacheKey}`, {\n                url,\n                content,\n            });\n            return content;\n        } catch (error) {\n            console.error(\"Error:\", error);\n            return {\n                title: url,\n                description: \"Error, could not fetch content\",\n                bodyContent: \"\",\n            };\n        } finally {\n            if (page) {\n                await page.close();\n            }\n        }\n    }\n\n    private async detectCaptcha(page: Page): Promise<boolean> {\n        const captchaSelectors = [\n            'iframe[src*=\"captcha\"]',\n            'div[class*=\"captcha\"]',\n            \"#captcha\",\n            \".g-recaptcha\",\n            \".h-captcha\",\n        ];\n\n        for (const selector of captchaSelectors) {\n            const element = await page.$(selector);\n            if (element) return true;\n        }\n\n        return false;\n    }\n\n    private async solveCaptcha(page: Page, url: string): Promise<void> {\n        try {\n            const hcaptchaKey = await this.getHCaptchaWebsiteKey(page);\n            if (hcaptchaKey) {\n                const solution = await this.captchaSolver.hcaptchaProxyless({\n                    websiteURL: url,\n                    websiteKey: hcaptchaKey,\n                });\n                await page.evaluate((token) => {\n                    // @ts-ignore\n                    window.hcaptcha.setResponse(token);\n                }, solution.gRecaptchaResponse);\n                return;\n            }\n\n            const recaptchaKey = await this.getReCaptchaWebsiteKey(page);\n            if (recaptchaKey) {\n                const solution = await this.captchaSolver.recaptchaV2Proxyless({\n                    websiteURL: url,\n                    websiteKey: recaptchaKey,\n                });\n                await page.evaluate((token) => {\n                    // @ts-ignore\n                    document.getElementById(\"g-recaptcha-response\").innerHTML =\n                        token;\n                }, solution.gRecaptchaResponse);\n            }\n        } catch (error) {\n            console.error(\"Error solving CAPTCHA:\", error);\n        }\n    }\n\n    private async getHCaptchaWebsiteKey(page: Page): Promise<string> {\n        return page.evaluate(() => {\n            const hcaptchaIframe = document.querySelector(\n                'iframe[src*=\"hcaptcha.com\"]'\n            );\n            if (hcaptchaIframe) {\n                const src = hcaptchaIframe.getAttribute(\"src\");\n                const match = src?.match(/sitekey=([^&]*)/);\n                return match ? match[1] : \"\";\n            }\n            return \"\";\n        });\n    }\n\n    private async getReCaptchaWebsiteKey(page: Page): Promise<string> {\n        return page.evaluate(() => {\n            const recaptchaElement = document.querySelector(\".g-recaptcha\");\n            return recaptchaElement\n                ? recaptchaElement.getAttribute(\"data-sitekey\") || \"\"\n                : \"\";\n        });\n    }\n\n    private async tryAlternativeSources(\n        url: string,\n        runtime: IAgentRuntime\n    ): Promise<{ title: string; description: string; bodyContent: string }> {\n        // Try Internet Archive\n        const archiveUrl = `https://web.archive.org/web/${url}`;\n        try {\n            return await this.fetchPageContent(archiveUrl, runtime);\n        } catch (error) {\n            console.error(\"Error fetching from Internet Archive:\", error);\n        }\n\n        // Try Google Search as a last resort\n        const googleSearchUrl = `https://www.google.com/search?q=${encodeURIComponent(url)}`;\n        try {\n            return await this.fetchPageContent(googleSearchUrl, runtime);\n        } catch (error) {\n            console.error(\"Error fetching from Google Search:\", error);\n            console.error(\"Failed to fetch content from alternative sources\");\n            return {\n                title: url,\n                description:\n                    \"Error, could not fetch content from alternative sources\",\n                bodyContent: \"\",\n            };\n        }\n    }\n}\n","import { elizaLogger, models } from \"@ai16z/eliza\";\nimport { Service } from \"@ai16z/eliza\";\nimport {\n    IAgentRuntime,\n    ModelProviderName,\n    ServiceType,\n    IImageDescriptionService,\n} from \"@ai16z/eliza\";\nimport {\n    AutoProcessor,\n    AutoTokenizer,\n    env,\n    Florence2ForConditionalGeneration,\n    Florence2Processor,\n    PreTrainedModel,\n    PreTrainedTokenizer,\n    RawImage,\n    type Tensor,\n} from \"@huggingface/transformers\";\nimport fs from \"fs\";\nimport gifFrames from \"gif-frames\";\nimport os from \"os\";\nimport path from \"path\";\n\nexport class ImageDescriptionService\n    extends Service\n    implements IImageDescriptionService\n{\n    static serviceType: ServiceType = ServiceType.IMAGE_DESCRIPTION;\n\n    private modelId: string = \"onnx-community/Florence-2-base-ft\";\n    private device: string = \"gpu\";\n    private model: PreTrainedModel | null = null;\n    private processor: Florence2Processor | null = null;\n    private tokenizer: PreTrainedTokenizer | null = null;\n    private initialized: boolean = false;\n    private runtime: IAgentRuntime | null = null;\n    private queue: string[] = [];\n    private processing: boolean = false;\n\n    getInstance(): IImageDescriptionService {\n        return ImageDescriptionService.getInstance();\n    }\n\n    async initialize(runtime: IAgentRuntime): Promise<void> {\n        this.runtime = runtime;\n        const model = models[runtime?.character?.modelProvider];\n\n        if (model === models[ModelProviderName.LLAMALOCAL]) {\n            await this.initializeLocalModel();\n        } else {\n            this.modelId = \"gpt-4o-mini\";\n            this.device = \"cloud\";\n        }\n\n        this.initialized = true;\n    }\n\n    private async initializeLocalModel(): Promise<void> {\n        env.allowLocalModels = false;\n        env.allowRemoteModels = true;\n        env.backends.onnx.logLevel = \"fatal\";\n        env.backends.onnx.wasm.proxy = false;\n        env.backends.onnx.wasm.numThreads = 1;\n\n        elizaLogger.log(\"Downloading Florence model...\");\n\n        this.model = await Florence2ForConditionalGeneration.from_pretrained(\n            this.modelId,\n            {\n                device: \"gpu\",\n                progress_callback: (progress) => {\n                    if (progress.status === \"downloading\") {\n                        elizaLogger.log(\n                            `Model download progress: ${JSON.stringify(progress)}`\n                        );\n                    }\n                },\n            }\n        );\n\n        elizaLogger.success(\"Florence model downloaded successfully\");\n\n        this.processor = (await AutoProcessor.from_pretrained(\n            this.modelId\n        )) as Florence2Processor;\n        this.tokenizer = await AutoTokenizer.from_pretrained(this.modelId);\n    }\n\n    async describeImage(\n        imageUrl: string\n    ): Promise<{ title: string; description: string }> {\n        if (!this.initialized) {\n            throw new Error(\"ImageDescriptionService not initialized\");\n        }\n\n        if (this.device === \"cloud\") {\n            if (!this.runtime) {\n                throw new Error(\n                    \"Runtime is required for OpenAI image recognition\"\n                );\n            }\n            return this.recognizeWithOpenAI(imageUrl);\n        }\n\n        this.queue.push(imageUrl);\n        this.processQueue();\n\n        return new Promise((resolve, reject) => {\n            const checkQueue = () => {\n                const index = this.queue.indexOf(imageUrl);\n                if (index !== -1) {\n                    setTimeout(checkQueue, 100);\n                } else {\n                    resolve(this.processImage(imageUrl));\n                }\n            };\n            checkQueue();\n        });\n    }\n\n    private async recognizeWithOpenAI(\n        imageUrl: string\n    ): Promise<{ title: string; description: string }> {\n        const isGif = imageUrl.toLowerCase().endsWith(\".gif\");\n        let imageData: Buffer | null = null;\n\n        try {\n            if (isGif) {\n                const { filePath } =\n                    await this.extractFirstFrameFromGif(imageUrl);\n                imageData = fs.readFileSync(filePath);\n            } else {\n                const response = await fetch(imageUrl);\n                if (!response.ok) {\n                    throw new Error(\n                        `Failed to fetch image: ${response.statusText}`\n                    );\n                }\n                imageData = Buffer.from(await response.arrayBuffer());\n            }\n\n            if (!imageData || imageData.length === 0) {\n                throw new Error(\"Failed to fetch image data\");\n            }\n\n            const prompt =\n                \"Describe this image and give it a title. The first line should be the title, and then a line break, then a detailed description of the image. Respond with the format 'title\\ndescription'\";\n            const text = await this.requestOpenAI(\n                imageUrl,\n                imageData,\n                prompt,\n                isGif\n            );\n\n            const [title, ...descriptionParts] = text.split(\"\\n\");\n            return {\n                title,\n                description: descriptionParts.join(\"\\n\"),\n            };\n        } catch (error) {\n            elizaLogger.error(\"Error in recognizeWithOpenAI:\", error);\n            throw error;\n        }\n    }\n\n    private async requestOpenAI(\n        imageUrl: string,\n        imageData: Buffer,\n        prompt: string,\n        isGif: boolean\n    ): Promise<string> {\n        for (let attempt = 0; attempt < 3; attempt++) {\n            try {\n                const content = [\n                    { type: \"text\", text: prompt },\n                    {\n                        type: \"image_url\",\n                        image_url: {\n                            url: isGif\n                                ? `data:image/png;base64,${imageData.toString(\"base64\")}`\n                                : imageUrl,\n                        },\n                    },\n                ];\n\n                const response = await fetch(\n                    \"https://api.openai.com/v1/chat/completions\",\n                    {\n                        method: \"POST\",\n                        headers: {\n                            \"Content-Type\": \"application/json\",\n                            Authorization: `Bearer ${this.runtime.getSetting(\"OPENAI_API_KEY\")}`,\n                        },\n                        body: JSON.stringify({\n                            model: \"gpt-4o-mini\",\n                            messages: [{ role: \"user\", content }],\n                            max_tokens: isGif ? 500 : 300,\n                        }),\n                    }\n                );\n\n                if (!response.ok) {\n                    throw new Error(`HTTP error! status: ${response.status}`);\n                }\n\n                const data = await response.json();\n                return data.choices[0].message.content;\n            } catch (error) {\n                elizaLogger.error(\n                    `OpenAI request failed (attempt ${attempt + 1}):`,\n                    error\n                );\n                if (attempt === 2) throw error;\n            }\n        }\n        throw new Error(\n            \"Failed to recognize image with OpenAI after 3 attempts\"\n        );\n    }\n\n    private async processQueue(): Promise<void> {\n        if (this.processing || this.queue.length === 0) return;\n\n        this.processing = true;\n        while (this.queue.length > 0) {\n            const imageUrl = this.queue.shift();\n            await this.processImage(imageUrl);\n        }\n        this.processing = false;\n    }\n\n    private async processImage(\n        imageUrl: string\n    ): Promise<{ title: string; description: string }> {\n        if (!this.model || !this.processor || !this.tokenizer) {\n            throw new Error(\"Model components not initialized\");\n        }\n\n        elizaLogger.log(\"Processing image:\", imageUrl);\n        const isGif = imageUrl.toLowerCase().endsWith(\".gif\");\n        let imageToProcess = imageUrl;\n\n        try {\n            if (isGif) {\n                elizaLogger.log(\"Extracting first frame from GIF\");\n                const { filePath } =\n                    await this.extractFirstFrameFromGif(imageUrl);\n                imageToProcess = filePath;\n            }\n\n            const image = await RawImage.fromURL(imageToProcess);\n            const visionInputs = await this.processor(image);\n            const prompts =\n                this.processor.construct_prompts(\"<DETAILED_CAPTION>\");\n            const textInputs = this.tokenizer(prompts);\n\n            elizaLogger.log(\"Generating image description\");\n            const generatedIds = (await this.model.generate({\n                ...textInputs,\n                ...visionInputs,\n                max_new_tokens: 256,\n            })) as Tensor;\n\n            const generatedText = this.tokenizer.batch_decode(generatedIds, {\n                skip_special_tokens: false,\n            })[0];\n\n            const result = this.processor.post_process_generation(\n                generatedText,\n                \"<DETAILED_CAPTION>\",\n                image.size\n            );\n\n            const detailedCaption = result[\"<DETAILED_CAPTION>\"] as string;\n            return { title: detailedCaption, description: detailedCaption };\n        } catch (error) {\n            elizaLogger.error(\"Error processing image:\", error);\n            throw error;\n        } finally {\n            if (isGif && imageToProcess !== imageUrl) {\n                fs.unlinkSync(imageToProcess);\n            }\n        }\n    }\n\n    private async extractFirstFrameFromGif(\n        gifUrl: string\n    ): Promise<{ filePath: string }> {\n        const frameData = await gifFrames({\n            url: gifUrl,\n            frames: 1,\n            outputType: \"png\",\n        });\n\n        const tempFilePath = path.join(\n            os.tmpdir(),\n            `gif_frame_${Date.now()}.png`\n        );\n\n        return new Promise((resolve, reject) => {\n            const writeStream = fs.createWriteStream(tempFilePath);\n            frameData[0].getImage().pipe(writeStream);\n            writeStream.on(\"finish\", () => resolve({ filePath: tempFilePath }));\n            writeStream.on(\"error\", reject);\n        });\n    }\n}\n\nexport default ImageDescriptionService;\n","import { elizaLogger, IAgentRuntime, ServiceType } from \"@ai16z/eliza\";\nimport { Service } from \"@ai16z/eliza\";\nimport fs from \"fs\";\nimport https from \"https\";\nimport {\n    GbnfJsonSchema,\n    getLlama,\n    Llama,\n    LlamaContext,\n    LlamaContextSequence,\n    LlamaContextSequenceRepeatPenalty,\n    LlamaJsonSchemaGrammar,\n    LlamaModel,\n    Token,\n} from \"node-llama-cpp\";\nimport path from \"path\";\nimport si from \"systeminformation\";\nimport { fileURLToPath } from \"url\";\n\nconst wordsToPunish = [\n    \" please\",\n    \" feel\",\n    \" free\",\n    \"!\",\n    \"–\",\n    \"—\",\n    \"?\",\n    \".\",\n    \",\",\n    \"; \",\n    \" cosmos\",\n    \" tapestry\",\n    \" tapestries\",\n    \" glitch\",\n    \" matrix\",\n    \" cyberspace\",\n    \" troll\",\n    \" questions\",\n    \" topics\",\n    \" discuss\",\n    \" basically\",\n    \" simulation\",\n    \" simulate\",\n    \" universe\",\n    \" like\",\n    \" debug\",\n    \" debugging\",\n    \" wild\",\n    \" existential\",\n    \" juicy\",\n    \" circuits\",\n    \" help\",\n    \" ask\",\n    \" happy\",\n    \" just\",\n    \" cosmic\",\n    \" cool\",\n    \" joke\",\n    \" punchline\",\n    \" fancy\",\n    \" glad\",\n    \" assist\",\n    \" algorithm\",\n    \" Indeed\",\n    \" Furthermore\",\n    \" However\",\n    \" Notably\",\n    \" Therefore\",\n    \" Additionally\",\n    \" conclusion\",\n    \" Significantly\",\n    \" Consequently\",\n    \" Thus\",\n    \" What\",\n    \" Otherwise\",\n    \" Moreover\",\n    \" Subsequently\",\n    \" Accordingly\",\n    \" Unlock\",\n    \" Unleash\",\n    \" buckle\",\n    \" pave\",\n    \" forefront\",\n    \" harness\",\n    \" harnessing\",\n    \" bridging\",\n    \" bridging\",\n    \" Spearhead\",\n    \" spearheading\",\n    \" Foster\",\n    \" foster\",\n    \" environmental\",\n    \" impact\",\n    \" Navigate\",\n    \" navigating\",\n    \" challenges\",\n    \" chaos\",\n    \" social\",\n    \" inclusion\",\n    \" inclusive\",\n    \" diversity\",\n    \" diverse\",\n    \" delve\",\n    \" noise\",\n    \" infinite\",\n    \" insanity\",\n    \" coffee\",\n    \" singularity\",\n    \" AI\",\n    \" digital\",\n    \" artificial\",\n    \" intelligence\",\n    \" consciousness\",\n    \" reality\",\n    \" metaverse\",\n    \" virtual\",\n    \" virtual reality\",\n    \" VR\",\n    \" Metaverse\",\n    \" humanity\",\n];\n\nconst __dirname = path.dirname(fileURLToPath(import.meta.url));\n\nconst jsonSchemaGrammar: Readonly<{\n    type: string;\n    properties: {\n        user: {\n            type: string;\n        };\n        content: {\n            type: string;\n        };\n    };\n}> = {\n    type: \"object\",\n    properties: {\n        user: {\n            type: \"string\",\n        },\n        content: {\n            type: \"string\",\n        },\n    },\n};\n\ninterface QueuedMessage {\n    context: string;\n    temperature: number;\n    stop: string[];\n    max_tokens: number;\n    frequency_penalty: number;\n    presence_penalty: number;\n    useGrammar: boolean;\n    resolve: (value: any | string | PromiseLike<any | string>) => void;\n    reject: (reason?: any) => void;\n}\n\nexport class LlamaService extends Service {\n    private llama: Llama | undefined;\n    private model: LlamaModel | undefined;\n    private modelPath: string;\n    private grammar: LlamaJsonSchemaGrammar<GbnfJsonSchema> | undefined;\n    private ctx: LlamaContext | undefined;\n    private sequence: LlamaContextSequence | undefined;\n    private modelUrl: string;\n\n    private messageQueue: QueuedMessage[] = [];\n    private isProcessing: boolean = false;\n    private modelInitialized: boolean = false;\n\n    static serviceType: ServiceType = ServiceType.TEXT_GENERATION;\n\n    constructor() {\n        super();\n        this.llama = undefined;\n        this.model = undefined;\n        this.modelUrl =\n            \"https://huggingface.co/NousResearch/Hermes-3-Llama-3.1-8B-GGUF/resolve/main/Hermes-3-Llama-3.1-8B.Q8_0.gguf?download=true\";\n        const modelName = \"model.gguf\";\n        this.modelPath = path.join(__dirname, modelName);\n    }\n\n    async initialize(runtime: IAgentRuntime): Promise<void> {}\n\n    private async ensureInitialized() {\n        if (!this.modelInitialized) {\n            await this.initializeModel();\n        }\n    }\n\n    async initializeModel() {\n        try {\n            await this.checkModel();\n\n            const systemInfo = await si.graphics();\n            const hasCUDA = systemInfo.controllers.some((controller) =>\n                controller.vendor.toLowerCase().includes(\"nvidia\")\n            );\n\n            if (hasCUDA) {\n                console.log(\"**** LlamaService: CUDA detected\");\n            } else {\n                console.warn(\n                    \"**** LlamaService: No CUDA detected - local response will be slow\"\n                );\n            }\n\n            this.llama = await getLlama({\n                gpu: \"cuda\",\n            });\n            const grammar = new LlamaJsonSchemaGrammar(\n                this.llama,\n                jsonSchemaGrammar as GbnfJsonSchema\n            );\n            this.grammar = grammar;\n\n            this.model = await this.llama.loadModel({\n                modelPath: this.modelPath,\n            });\n\n            this.ctx = await this.model.createContext({ contextSize: 8192 });\n            this.sequence = this.ctx.getSequence();\n\n            this.modelInitialized = true;\n            this.processQueue();\n        } catch (error) {\n            console.error(\n                \"Model initialization failed. Deleting model and retrying...\",\n                error\n            );\n            await this.deleteModel();\n            await this.initializeModel();\n        }\n    }\n\n    async checkModel() {\n        if (!fs.existsSync(this.modelPath)) {\n            await new Promise<void>((resolve, reject) => {\n                const file = fs.createWriteStream(this.modelPath);\n                let downloadedSize = 0;\n\n                const downloadModel = (url: string) => {\n                    https\n                        .get(url, (response) => {\n                            const isRedirect =\n                                response.statusCode >= 300 &&\n                                response.statusCode < 400;\n                            if (isRedirect) {\n                                const redirectUrl = response.headers.location;\n                                if (redirectUrl) {\n                                    downloadModel(redirectUrl);\n                                    return;\n                                } else {\n                                    reject(new Error(\"Redirect URL not found\"));\n                                    return;\n                                }\n                            }\n\n                            const totalSize = parseInt(\n                                response.headers[\"content-length\"] ?? \"0\",\n                                10\n                            );\n\n                            response.on(\"data\", (chunk) => {\n                                downloadedSize += chunk.length;\n                                file.write(chunk);\n\n                                // Log progress\n                                const progress = (\n                                    (downloadedSize / totalSize) *\n                                    100\n                                ).toFixed(2);\n                                process.stdout.write(\n                                    `Downloaded ${progress}%\\r`\n                                );\n                            });\n\n                            response.on(\"end\", () => {\n                                file.end();\n                                resolve();\n                            });\n                        })\n                        .on(\"error\", (err) => {\n                            fs.unlink(this.modelPath, () => {}); // Delete the file async\n                            console.error(\"Download failed:\", err.message);\n                            reject(err);\n                        });\n                };\n\n                downloadModel(this.modelUrl);\n\n                file.on(\"error\", (err) => {\n                    fs.unlink(this.modelPath, () => {}); // Delete the file async\n                    console.error(\"File write error:\", err.message);\n                    reject(err);\n                });\n            });\n        } else {\n            elizaLogger.warn(\"Model already exists.\");\n        }\n    }\n\n    async deleteModel() {\n        if (fs.existsSync(this.modelPath)) {\n            fs.unlinkSync(this.modelPath);\n        }\n    }\n\n    async queueMessageCompletion(\n        context: string,\n        temperature: number,\n        stop: string[],\n        frequency_penalty: number,\n        presence_penalty: number,\n        max_tokens: number\n    ): Promise<any> {\n        await this.ensureInitialized();\n        return new Promise((resolve, reject) => {\n            this.messageQueue.push({\n                context,\n                temperature,\n                stop,\n                frequency_penalty,\n                presence_penalty,\n                max_tokens,\n                useGrammar: true,\n                resolve,\n                reject,\n            });\n            this.processQueue();\n        });\n    }\n\n    async queueTextCompletion(\n        context: string,\n        temperature: number,\n        stop: string[],\n        frequency_penalty: number,\n        presence_penalty: number,\n        max_tokens: number\n    ): Promise<string> {\n        await this.ensureInitialized();\n\n        return new Promise((resolve, reject) => {\n            this.messageQueue.push({\n                context,\n                temperature,\n                stop,\n                frequency_penalty: frequency_penalty ?? 1.0,\n                presence_penalty: presence_penalty ?? 1.0,\n                max_tokens,\n                useGrammar: false,\n                resolve,\n                reject,\n            });\n            this.processQueue();\n        });\n    }\n\n    private async processQueue() {\n        if (\n            this.isProcessing ||\n            this.messageQueue.length === 0 ||\n            !this.modelInitialized\n        ) {\n            return;\n        }\n\n        this.isProcessing = true;\n\n        while (this.messageQueue.length > 0) {\n            const message = this.messageQueue.shift();\n            if (message) {\n                try {\n                    const response = await this.getCompletionResponse(\n                        message.context,\n                        message.temperature,\n                        message.stop,\n                        message.frequency_penalty,\n                        message.presence_penalty,\n                        message.max_tokens,\n                        message.useGrammar\n                    );\n                    message.resolve(response);\n                } catch (error) {\n                    message.reject(error);\n                }\n            }\n        }\n\n        this.isProcessing = false;\n    }\n\n    private async getCompletionResponse(\n        context: string,\n        temperature: number,\n        stop: string[],\n        frequency_penalty: number,\n        presence_penalty: number,\n        max_tokens: number,\n        useGrammar: boolean\n    ): Promise<any | string> {\n        if (!this.sequence) {\n            throw new Error(\"Model not initialized.\");\n        }\n\n        const tokens = this.model!.tokenize(context);\n\n        // tokenize the words to punish\n        const wordsToPunishTokens = wordsToPunish\n            .map((word) => this.model!.tokenize(word))\n            .flat();\n\n        const repeatPenalty: LlamaContextSequenceRepeatPenalty = {\n            punishTokens: () => wordsToPunishTokens,\n            penalty: 1.2,\n            frequencyPenalty: frequency_penalty,\n            presencePenalty: presence_penalty,\n        };\n\n        const responseTokens: Token[] = [];\n\n        for await (const token of this.sequence.evaluate(tokens, {\n            temperature: Number(temperature),\n            repeatPenalty: repeatPenalty,\n            grammarEvaluationState: useGrammar ? this.grammar : undefined,\n            yieldEogToken: false,\n        })) {\n            const current = this.model.detokenize([...responseTokens, token]);\n            if ([...stop].some((s) => current.includes(s))) {\n                console.log(\"Stop sequence found\");\n                break;\n            }\n\n            responseTokens.push(token);\n            process.stdout.write(this.model!.detokenize([token]));\n            if (useGrammar) {\n                if (current.replaceAll(\"\\n\", \"\").includes(\"}```\")) {\n                    console.log(\"JSON block found\");\n                    break;\n                }\n            }\n            if (responseTokens.length > max_tokens) {\n                console.log(\"Max tokens reached\");\n                break;\n            }\n        }\n\n        const response = this.model!.detokenize(responseTokens);\n\n        if (!response) {\n            throw new Error(\"Response is undefined\");\n        }\n\n        if (useGrammar) {\n            // extract everything between ```json and ```\n            let jsonString = response.match(/```json(.*?)```/s)?.[1].trim();\n            if (!jsonString) {\n                // try parsing response as JSON\n                try {\n                    jsonString = JSON.stringify(JSON.parse(response));\n                } catch {\n                    throw new Error(\"JSON string not found\");\n                }\n            }\n            try {\n                const parsedResponse = JSON.parse(jsonString);\n                if (!parsedResponse) {\n                    throw new Error(\"Parsed response is undefined\");\n                }\n                await this.sequence.clearHistory();\n                return parsedResponse;\n            } catch (error) {\n                console.error(\"Error parsing JSON:\", error);\n            }\n        } else {\n            await this.sequence.clearHistory();\n            return response;\n        }\n    }\n\n    async getEmbeddingResponse(input: string): Promise<number[] | undefined> {\n        await this.ensureInitialized();\n        if (!this.model) {\n            throw new Error(\"Model not initialized. Call initialize() first.\");\n        }\n\n        const embeddingContext = await this.model.createEmbeddingContext();\n        const embedding = await embeddingContext.getEmbeddingFor(input);\n        return embedding?.vector ? [...embedding.vector] : undefined;\n    }\n}\n\nexport default LlamaService;\n","import { IAgentRuntime, IPdfService, Service, ServiceType } from \"@ai16z/eliza\";\nimport { getDocument, PDFDocumentProxy } from \"pdfjs-dist\";\nimport { TextItem, TextMarkedContent } from \"pdfjs-dist/types/src/display/api\";\n\nexport class PdfService extends Service implements IPdfService {\n    static serviceType: ServiceType = ServiceType.PDF;\n\n    constructor() {\n        super();\n    }\n\n    getInstance(): IPdfService {\n        return PdfService.getInstance();\n    }\n\n    async initialize(runtime: IAgentRuntime): Promise<void> {}\n\n    async convertPdfToText(pdfBuffer: Buffer): Promise<string> {\n        // Convert Buffer to Uint8Array\n        const uint8Array = new Uint8Array(pdfBuffer);\n\n        const pdf: PDFDocumentProxy = await getDocument({ data: uint8Array })\n            .promise;\n        const numPages = pdf.numPages;\n        const textPages: string[] = [];\n\n        for (let pageNum = 1; pageNum <= numPages; pageNum++) {\n            const page = await pdf.getPage(pageNum);\n            const textContent = await page.getTextContent();\n            const pageText = textContent.items\n                .filter(isTextItem)\n                .map((item) => item.str)\n                .join(\" \");\n            textPages.push(pageText);\n        }\n\n        return textPages.join(\"\\n\");\n    }\n}\n\n// Type guard function\nfunction isTextItem(item: TextItem | TextMarkedContent): item is TextItem {\n    return \"str\" in item;\n}\n","import { PassThrough, Readable } from \"stream\";\nimport { IAgentRuntime, ISpeechService, ServiceType } from \"@ai16z/eliza\";\nimport { getWavHeader } from \"./audioUtils.ts\";\nimport { Service } from \"@ai16z/eliza\";\nimport { validateNodeConfig } from \"../enviroment.ts\";\nimport * as Echogarden from \"echogarden\";\n\nfunction prependWavHeader(\n    readable: Readable,\n    audioLength: number,\n    sampleRate: number,\n    channelCount: number = 1,\n    bitsPerSample: number = 16\n): Readable {\n    const wavHeader = getWavHeader(\n        audioLength,\n        sampleRate,\n        channelCount,\n        bitsPerSample\n    );\n    let pushedHeader = false;\n    const passThrough = new PassThrough();\n    readable.on(\"data\", function (data) {\n        if (!pushedHeader) {\n            passThrough.push(wavHeader);\n            pushedHeader = true;\n        }\n        passThrough.push(data);\n    });\n    readable.on(\"end\", function () {\n        passThrough.end();\n    });\n    return passThrough;\n}\n\nasync function textToSpeech(runtime: IAgentRuntime, text: string) {\n    await validateNodeConfig(runtime);\n\n    try {\n        const response = await fetch(\n            `https://api.elevenlabs.io/v1/text-to-speech/${runtime.getSetting(\"ELEVENLABS_VOICE_ID\")}/stream?optimize_streaming_latency=${runtime.getSetting(\"ELEVENLABS_OPTIMIZE_STREAMING_LATENCY\")}&output_format=${runtime.getSetting(\"ELEVENLABS_OUTPUT_FORMAT\")}`,\n            {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    \"xi-api-key\": runtime.getSetting(\"ELEVENLABS_XI_API_KEY\"),\n                },\n                body: JSON.stringify({\n                    model_id: runtime.getSetting(\"ELEVENLABS_MODEL_ID\"),\n                    text: text,\n                    voice_settings: {\n                        similarity_boost: runtime.getSetting(\n                            \"ELEVENLABS_VOICE_SIMILARITY_BOOST\"\n                        ),\n                        stability: runtime.getSetting(\n                            \"ELEVENLABS_VOICE_STABILITY\"\n                        ),\n                        style: runtime.getSetting(\"ELEVENLABS_VOICE_STYLE\"),\n                        use_speaker_boost: runtime.getSetting(\n                            \"ELEVENLABS_VOICE_USE_SPEAKER_BOOST\"\n                        ),\n                    },\n                }),\n            }\n        );\n\n        const status = response.status;\n        if (status != 200) {\n            const errorBodyString = await response.text();\n            const errorBody = JSON.parse(errorBodyString);\n\n            // Check for quota exceeded error\n            if (\n                status === 401 &&\n                errorBody.detail?.status === \"quota_exceeded\"\n            ) {\n                console.log(\"ElevenLabs quota exceeded, falling back to VITS\");\n                throw new Error(\"QUOTA_EXCEEDED\");\n            }\n\n            throw new Error(\n                `Received status ${status} from Eleven Labs API: ${errorBodyString}`\n            );\n        }\n\n        if (response) {\n            const reader = response.body?.getReader();\n            const readable = new Readable({\n                read() {\n                    reader &&\n                        reader.read().then(({ done, value }) => {\n                            if (done) {\n                                this.push(null);\n                            } else {\n                                this.push(value);\n                            }\n                        });\n                },\n            });\n\n            if (\n                runtime\n                    .getSetting(\"ELEVENLABS_OUTPUT_FORMAT\")\n                    .startsWith(\"pcm_\")\n            ) {\n                const sampleRate = parseInt(\n                    runtime.getSetting(\"ELEVENLABS_OUTPUT_FORMAT\").substring(4)\n                );\n                const withHeader = prependWavHeader(\n                    readable,\n                    1024 * 1024 * 100,\n                    sampleRate,\n                    1,\n                    16\n                );\n                return withHeader;\n            } else {\n                return readable;\n            }\n        } else {\n            return new Readable({\n                read() {},\n            });\n        }\n    } catch (error) {\n        if (error.message === \"QUOTA_EXCEEDED\") {\n            // Fall back to VITS\n            const { audio } = await Echogarden.synthesize(text, {\n                engine: \"vits\",\n                voice: \"en_US-hfc_female-medium\",\n            });\n\n            let wavStream: Readable;\n            if (audio instanceof Buffer) {\n                console.log(\"audio is a buffer\");\n                wavStream = Readable.from(audio);\n            } else if (\"audioChannels\" in audio && \"sampleRate\" in audio) {\n                console.log(\"audio is a RawAudio\");\n                const floatBuffer = Buffer.from(audio.audioChannels[0].buffer);\n                console.log(\"buffer length: \", floatBuffer.length);\n\n                // Get the sample rate from the RawAudio object\n                const sampleRate = audio.sampleRate;\n\n                // Create a Float32Array view of the floatBuffer\n                const floatArray = new Float32Array(floatBuffer.buffer);\n\n                // Convert 32-bit float audio to 16-bit PCM\n                const pcmBuffer = new Int16Array(floatArray.length);\n                for (let i = 0; i < floatArray.length; i++) {\n                    pcmBuffer[i] = Math.round(floatArray[i] * 32767);\n                }\n\n                // Prepend WAV header to the buffer\n                const wavHeaderBuffer = getWavHeader(\n                    pcmBuffer.length * 2,\n                    sampleRate,\n                    1,\n                    16\n                );\n                const wavBuffer = Buffer.concat([\n                    wavHeaderBuffer,\n                    Buffer.from(pcmBuffer.buffer),\n                ]);\n\n                wavStream = Readable.from(wavBuffer);\n            } else {\n                throw new Error(\"Unsupported audio format\");\n            }\n            return wavStream;\n        }\n        throw error; // Re-throw other errors\n    }\n}\n\nexport class SpeechService extends Service implements ISpeechService {\n    static serviceType: ServiceType = ServiceType.SPEECH_GENERATION;\n\n    async initialize(runtime: IAgentRuntime): Promise<void> {}\n\n    getInstance(): ISpeechService {\n        return SpeechService.getInstance();\n    }\n\n    async generate(runtime: IAgentRuntime, text: string): Promise<Readable> {\n        try {\n            // check for elevenlabs API key\n            if (runtime.getSetting(\"ELEVENLABS_XI_API_KEY\")) {\n                return await textToSpeech(runtime, text);\n            }\n\n            // Default to VITS if no ElevenLabs API key\n            const { audio } = await Echogarden.synthesize(text, {\n                engine: \"vits\",\n                voice: \"en_US-hfc_female-medium\",\n            });\n\n            let wavStream: Readable;\n            if (audio instanceof Buffer) {\n                console.log(\"audio is a buffer\");\n                wavStream = Readable.from(audio);\n            } else if (\"audioChannels\" in audio && \"sampleRate\" in audio) {\n                console.log(\"audio is a RawAudio\");\n                const floatBuffer = Buffer.from(audio.audioChannels[0].buffer);\n                console.log(\"buffer length: \", floatBuffer.length);\n\n                // Get the sample rate from the RawAudio object\n                const sampleRate = audio.sampleRate;\n\n                // Create a Float32Array view of the floatBuffer\n                const floatArray = new Float32Array(floatBuffer.buffer);\n\n                // Convert 32-bit float audio to 16-bit PCM\n                const pcmBuffer = new Int16Array(floatArray.length);\n                for (let i = 0; i < floatArray.length; i++) {\n                    pcmBuffer[i] = Math.round(floatArray[i] * 32767);\n                }\n\n                // Prepend WAV header to the buffer\n                const wavHeaderBuffer = getWavHeader(\n                    pcmBuffer.length * 2,\n                    sampleRate,\n                    1,\n                    16\n                );\n                const wavBuffer = Buffer.concat([\n                    wavHeaderBuffer,\n                    Buffer.from(pcmBuffer.buffer),\n                ]);\n\n                wavStream = Readable.from(wavBuffer);\n            } else {\n                throw new Error(\"Unsupported audio format\");\n            }\n\n            return wavStream;\n        } catch (error) {\n            console.error(\"Speech generation error:\", error);\n            // If ElevenLabs fails for any reason, fall back to VITS\n            const { audio } = await Echogarden.synthesize(text, {\n                engine: \"vits\",\n                voice: \"en_US-hfc_female-medium\",\n            });\n\n            let wavStream: Readable;\n            if (audio instanceof Buffer) {\n                console.log(\"audio is a buffer\");\n                wavStream = Readable.from(audio);\n            } else if (\"audioChannels\" in audio && \"sampleRate\" in audio) {\n                console.log(\"audio is a RawAudio\");\n                const floatBuffer = Buffer.from(audio.audioChannels[0].buffer);\n                console.log(\"buffer length: \", floatBuffer.length);\n\n                // Get the sample rate from the RawAudio object\n                const sampleRate = audio.sampleRate;\n\n                // Create a Float32Array view of the floatBuffer\n                const floatArray = new Float32Array(floatBuffer.buffer);\n\n                // Convert 32-bit float audio to 16-bit PCM\n                const pcmBuffer = new Int16Array(floatArray.length);\n                for (let i = 0; i < floatArray.length; i++) {\n                    pcmBuffer[i] = Math.round(floatArray[i] * 32767);\n                }\n\n                // Prepend WAV header to the buffer\n                const wavHeaderBuffer = getWavHeader(\n                    pcmBuffer.length * 2,\n                    sampleRate,\n                    1,\n                    16\n                );\n                const wavBuffer = Buffer.concat([\n                    wavHeaderBuffer,\n                    Buffer.from(pcmBuffer.buffer),\n                ]);\n\n                wavStream = Readable.from(wavBuffer);\n            } else {\n                throw new Error(\"Unsupported audio format\");\n            }\n\n            return wavStream;\n        }\n    }\n}\n","export function getWavHeader(\n    audioLength: number,\n    sampleRate: number,\n    channelCount: number = 1,\n    bitsPerSample: number = 16\n): Buffer {\n    const wavHeader = Buffer.alloc(44);\n    wavHeader.write(\"RIFF\", 0);\n    wavHeader.writeUInt32LE(36 + audioLength, 4); // Length of entire file in bytes minus 8\n    wavHeader.write(\"WAVE\", 8);\n    wavHeader.write(\"fmt \", 12);\n    wavHeader.writeUInt32LE(16, 16); // Length of format data\n    wavHeader.writeUInt16LE(1, 20); // Type of format (1 is PCM)\n    wavHeader.writeUInt16LE(channelCount, 22); // Number of channels\n    wavHeader.writeUInt32LE(sampleRate, 24); // Sample rate\n    wavHeader.writeUInt32LE(\n        (sampleRate * bitsPerSample * channelCount) / 8,\n        28\n    ); // Byte rate\n    wavHeader.writeUInt16LE((bitsPerSample * channelCount) / 8, 32); // Block align ((BitsPerSample * Channels) / 8)\n    wavHeader.writeUInt16LE(bitsPerSample, 34); // Bits per sample\n    wavHeader.write(\"data\", 36); // Data chunk header\n    wavHeader.writeUInt32LE(audioLength, 40); // Data chunk size\n    return wavHeader;\n}\n","import { IAgentRuntime } from \"@ai16z/eliza\";\nimport { z } from \"zod\";\n\nexport const nodeEnvSchema = z.object({\n    OPENAI_API_KEY: z.string().min(1, \"OpenAI API key is required\"),\n    ELEVENLABS_XI_API_KEY: z.string().optional(),\n    ELEVENLABS_MODEL_ID: z.string().min(1, \"ElevenLabs model ID is required\"),\n    ELEVENLABS_VOICE_ID: z.string().min(1, \"ElevenLabs voice ID is required\"),\n    ELEVENLABS_VOICE_STABILITY: z\n        .string()\n        .min(1, \"ElevenLabs voice stability is required\"),\n    ELEVENLABS_VOICE_SIMILARITY_BOOST: z\n        .string()\n        .min(1, \"ElevenLabs voice similarity boost is required\"),\n    ELEVENLABS_VOICE_STYLE: z\n        .string()\n        .min(1, \"ElevenLabs voice style is required\"),\n    ELEVENLABS_VOICE_USE_SPEAKER_BOOST: z\n        .string()\n        .min(1, \"ElevenLabs voice speaker boost setting is required\"),\n    ELEVENLABS_OPTIMIZE_STREAMING_LATENCY: z\n        .string()\n        .min(1, \"ElevenLabs streaming latency optimization is required\"),\n    ELEVENLABS_OUTPUT_FORMAT: z\n        .string()\n        .min(1, \"ElevenLabs output format is required\"),\n});\n\nexport type NodeConfig = z.infer<typeof nodeEnvSchema>;\n\nexport async function validateNodeConfig(\n    runtime: IAgentRuntime\n): Promise<NodeConfig> {\n    try {\n        const config = {\n            OPENAI_API_KEY:\n                runtime.getSetting(\"OPENAI_API_KEY\") ||\n                process.env.OPENAI_API_KEY,\n            ELEVENLABS_MODEL_ID:\n                runtime.getSetting(\"ELEVENLABS_MODEL_ID\") ||\n                process.env.ELEVENLABS_MODEL_ID,\n            ELEVENLABS_VOICE_ID:\n                runtime.getSetting(\"ELEVENLABS_VOICE_ID\") ||\n                process.env.ELEVENLABS_VOICE_ID,\n            ELEVENLABS_VOICE_STABILITY:\n                runtime.getSetting(\"ELEVENLABS_VOICE_STABILITY\") ||\n                process.env.ELEVENLABS_VOICE_STABILITY,\n            ELEVENLABS_VOICE_SIMILARITY_BOOST:\n                runtime.getSetting(\"ELEVENLABS_VOICE_SIMILARITY_BOOST\") ||\n                process.env.ELEVENLABS_VOICE_SIMILARITY_BOOST,\n            ELEVENLABS_VOICE_STYLE:\n                runtime.getSetting(\"ELEVENLABS_VOICE_STYLE\") ||\n                process.env.ELEVENLABS_VOICE_STYLE,\n            ELEVENLABS_VOICE_USE_SPEAKER_BOOST:\n                runtime.getSetting(\"ELEVENLABS_VOICE_USE_SPEAKER_BOOST\") ||\n                process.env.ELEVENLABS_VOICE_USE_SPEAKER_BOOST,\n            ELEVENLABS_OPTIMIZE_STREAMING_LATENCY:\n                runtime.getSetting(\"ELEVENLABS_OPTIMIZE_STREAMING_LATENCY\") ||\n                process.env.ELEVENLABS_OPTIMIZE_STREAMING_LATENCY,\n            ELEVENLABS_OUTPUT_FORMAT:\n                runtime.getSetting(\"ELEVENLABS_OUTPUT_FORMAT\") ||\n                process.env.ELEVENLABS_OUTPUT_FORMAT,\n        };\n\n        return nodeEnvSchema.parse(config);\n    } catch (error) {\n        if (error instanceof z.ZodError) {\n            const errorMessages = error.errors\n                .map((err) => `${err.path.join(\".\")}: ${err.message}`)\n                .join(\"\\n\");\n            throw new Error(\n                `Node configuration validation failed:\\n${errorMessages}`\n            );\n        }\n        throw error;\n    }\n}\n","import {\n    elizaLogger,\n    IAgentRuntime,\n    ITranscriptionService,\n    settings,\n} from \"@ai16z/eliza\";\nimport { Service, ServiceType } from \"@ai16z/eliza\";\nimport { exec } from \"child_process\";\nimport { File } from \"formdata-node\";\nimport fs from \"fs\";\nimport { nodewhisper } from \"nodejs-whisper\";\nimport OpenAI from \"openai\"; // todo, can probably move this to model provider or whateer\nimport os from \"os\";\nimport path from \"path\";\nimport { fileURLToPath } from \"url\";\nimport { promisify } from \"util\";\n\n// const __dirname = path.dirname(new URL(import.meta.url).pathname); #compatibility issues with windows\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\nconst execAsync = promisify(exec);\n\nexport class TranscriptionService\n    extends Service\n    implements ITranscriptionService\n{\n    static serviceType: ServiceType = ServiceType.TRANSCRIPTION;\n    private CONTENT_CACHE_DIR: string;\n    private DEBUG_AUDIO_DIR: string;\n    private TARGET_SAMPLE_RATE = 16000; // Common sample rate for speech recognition\n    private isCudaAvailable: boolean = false;\n    private openai: OpenAI | null = null;\n\n    private queue: { audioBuffer: ArrayBuffer; resolve: Function }[] = [];\n    private processing: boolean = false;\n\n    async initialize(runtime: IAgentRuntime): Promise<void> {}\n\n    constructor() {\n        super();\n        const rootDir = path.resolve(__dirname, \"../../\");\n        this.CONTENT_CACHE_DIR = path.join(rootDir, \"content_cache\");\n        this.DEBUG_AUDIO_DIR = path.join(rootDir, \"debug_audio\");\n        this.ensureCacheDirectoryExists();\n        this.ensureDebugDirectoryExists();\n        // TODO: It'd be nice to handle this more gracefully, but we can do local transcription for now\n        // TODO: remove the runtime from here, use it when called\n        // if (runtime.getSetting(\"OPENAI_API_KEY\")) {\n        //     this.openai = new OpenAI({\n        //         apiKey: runtime.getSetting(\"OPENAI_API_KEY\"),\n        //     });\n        // } else {\n        //     this.detectCuda();\n        // }\n    }\n\n    private ensureCacheDirectoryExists() {\n        if (!fs.existsSync(this.CONTENT_CACHE_DIR)) {\n            fs.mkdirSync(this.CONTENT_CACHE_DIR, { recursive: true });\n        }\n    }\n\n    private ensureDebugDirectoryExists() {\n        if (!fs.existsSync(this.DEBUG_AUDIO_DIR)) {\n            fs.mkdirSync(this.DEBUG_AUDIO_DIR, { recursive: true });\n        }\n    }\n\n    private detectCuda() {\n        const platform = os.platform();\n        if (platform === \"linux\") {\n            try {\n                fs.accessSync(\"/usr/local/cuda/bin/nvcc\", fs.constants.X_OK);\n                this.isCudaAvailable = true;\n                console.log(\n                    \"CUDA detected. Transcription will use CUDA acceleration.\"\n                );\n            } catch (error) {\n                console.log(\n                    \"CUDA not detected. Transcription will run on CPU.\"\n                );\n            }\n        } else if (platform === \"win32\") {\n            const cudaPath = path.join(\n                settings.CUDA_PATH ||\n                    \"C:\\\\Program Files\\\\NVIDIA GPU Computing Toolkit\\\\CUDA\\\\v11.0\",\n                \"bin\",\n                \"nvcc.exe\"\n            );\n            if (fs.existsSync(cudaPath)) {\n                this.isCudaAvailable = true;\n                console.log(\n                    \"CUDA detected. Transcription will use CUDA acceleration.\"\n                );\n            } else {\n                console.log(\n                    \"CUDA not detected. Transcription will run on CPU.\"\n                );\n            }\n        } else {\n            console.log(\n                \"CUDA not supported on this platform. Transcription will run on CPU.\"\n            );\n        }\n    }\n\n    private async convertAudio(inputBuffer: ArrayBuffer): Promise<Buffer> {\n        const inputPath = path.join(\n            this.CONTENT_CACHE_DIR,\n            `input_${Date.now()}.wav`\n        );\n        const outputPath = path.join(\n            this.CONTENT_CACHE_DIR,\n            `output_${Date.now()}.wav`\n        );\n\n        fs.writeFileSync(inputPath, Buffer.from(inputBuffer));\n\n        try {\n            const { stdout } = await execAsync(\n                `ffprobe -v error -show_entries stream=codec_name,sample_rate,channels -of json \"${inputPath}\"`\n            );\n            const probeResult = JSON.parse(stdout);\n            const stream = probeResult.streams[0];\n\n            elizaLogger.log(\"Input audio info:\", stream);\n\n            let ffmpegCommand = `ffmpeg -i \"${inputPath}\" -ar ${this.TARGET_SAMPLE_RATE} -ac 1`;\n\n            if (stream.codec_name === \"pcm_f32le\") {\n                ffmpegCommand += \" -acodec pcm_s16le\";\n            }\n\n            ffmpegCommand += ` \"${outputPath}\"`;\n\n            elizaLogger.log(\"FFmpeg command:\", ffmpegCommand);\n\n            await execAsync(ffmpegCommand);\n\n            const convertedBuffer = fs.readFileSync(outputPath);\n            fs.unlinkSync(inputPath);\n            fs.unlinkSync(outputPath);\n            return convertedBuffer;\n        } catch (error) {\n            elizaLogger.error(\"Error converting audio:\", error);\n            throw error;\n        }\n    }\n\n    private async saveDebugAudio(audioBuffer: ArrayBuffer, prefix: string) {\n        this.ensureDebugDirectoryExists();\n\n        const filename = `${prefix}_${Date.now()}.wav`;\n        const filePath = path.join(this.DEBUG_AUDIO_DIR, filename);\n\n        fs.writeFileSync(filePath, Buffer.from(audioBuffer));\n        elizaLogger.log(`Debug audio saved: ${filePath}`);\n    }\n\n    public async transcribeAttachment(\n        audioBuffer: ArrayBuffer\n    ): Promise<string | null> {\n        return await this.transcribe(audioBuffer);\n    }\n\n    public async transcribe(audioBuffer: ArrayBuffer): Promise<string | null> {\n        // if the audio buffer is less than .2 seconds, just return null\n        if (audioBuffer.byteLength < 0.2 * 16000) {\n            return null;\n        }\n        return new Promise((resolve) => {\n            this.queue.push({ audioBuffer, resolve });\n            if (!this.processing) {\n                this.processQueue();\n            }\n        });\n    }\n\n    public async transcribeAttachmentLocally(\n        audioBuffer: ArrayBuffer\n    ): Promise<string | null> {\n        return this.transcribeLocally(audioBuffer);\n    }\n\n    private async processQueue(): Promise<void> {\n        if (this.processing || this.queue.length === 0) {\n            return;\n        }\n\n        this.processing = true;\n\n        while (this.queue.length > 0) {\n            const { audioBuffer, resolve } = this.queue.shift()!;\n            let result: string | null = null;\n\n            if (this.openai) {\n                result = await this.transcribeWithOpenAI(audioBuffer);\n            } else {\n                result = await this.transcribeLocally(audioBuffer);\n            }\n\n            resolve(result);\n        }\n\n        this.processing = false;\n    }\n\n    private async transcribeWithOpenAI(\n        audioBuffer: ArrayBuffer\n    ): Promise<string | null> {\n        elizaLogger.log(\"Transcribing audio with OpenAI...\");\n\n        try {\n            await this.saveDebugAudio(audioBuffer, \"openai_input_original\");\n\n            const convertedBuffer = await this.convertAudio(audioBuffer);\n\n            await this.saveDebugAudio(\n                convertedBuffer,\n                \"openai_input_converted\"\n            );\n\n            const file = new File([convertedBuffer], \"audio.wav\", {\n                type: \"audio/wav\",\n            });\n\n            const result = await this.openai!.audio.transcriptions.create({\n                model: \"whisper-1\",\n                language: \"en\",\n                response_format: \"text\",\n                file: file,\n            });\n\n            const trimmedResult = (result as any).trim();\n            elizaLogger.log(`OpenAI speech to text result: \"${trimmedResult}\"`);\n\n            return trimmedResult;\n        } catch (error) {\n            elizaLogger.error(\n                \"Error in OpenAI speech-to-text conversion:\",\n                error\n            );\n            if (error.response) {\n                elizaLogger.error(\"Response data:\", error.response.data);\n                elizaLogger.error(\"Response status:\", error.response.status);\n                elizaLogger.error(\"Response headers:\", error.response.headers);\n            } else if (error.request) {\n                elizaLogger.error(\"No response received:\", error.request);\n            } else {\n                elizaLogger.error(\"Error setting up request:\", error.message);\n            }\n            return null;\n        }\n    }\n\n    public async transcribeLocally(\n        audioBuffer: ArrayBuffer\n    ): Promise<string | null> {\n        try {\n            elizaLogger.log(\"Transcribing audio locally...\");\n\n            await this.saveDebugAudio(audioBuffer, \"local_input_original\");\n\n            const convertedBuffer = await this.convertAudio(audioBuffer);\n\n            await this.saveDebugAudio(convertedBuffer, \"local_input_converted\");\n\n            const tempWavFile = path.join(\n                this.CONTENT_CACHE_DIR,\n                `temp_${Date.now()}.wav`\n            );\n            fs.writeFileSync(tempWavFile, convertedBuffer);\n\n            elizaLogger.debug(`Temporary WAV file created: ${tempWavFile}`);\n\n            let output = await nodewhisper(tempWavFile, {\n                modelName: \"base.en\",\n                autoDownloadModelName: \"base.en\",\n                verbose: false,\n                removeWavFileAfterTranscription: false,\n                withCuda: this.isCudaAvailable,\n                whisperOptions: {\n                    outputInText: true,\n                    outputInVtt: false,\n                    outputInSrt: false,\n                    outputInCsv: false,\n                    translateToEnglish: false,\n                    wordTimestamps: false,\n                    timestamps_length: 60,\n                    splitOnWord: true,\n                },\n            });\n\n            output = output\n                .split(\"\\n\")\n                .map((line) => {\n                    if (line.trim().startsWith(\"[\")) {\n                        const endIndex = line.indexOf(\"]\");\n                        return line.substring(endIndex + 1);\n                    }\n                    return line;\n                })\n                .join(\"\\n\");\n\n            fs.unlinkSync(tempWavFile);\n\n            if (!output || output.length < 5) {\n                elizaLogger.log(\"Output is null or too short, returning null\");\n                return null;\n            }\n            return output;\n        } catch (error) {\n            elizaLogger.error(\n                \"Error in local speech-to-text conversion:\",\n                error\n            );\n            return null;\n        }\n    }\n}\n","import { Service } from \"@ai16z/eliza\";\nimport {\n    IAgentRuntime,\n    ITranscriptionService,\n    Media,\n    ServiceType,\n    IVideoService,\n} from \"@ai16z/eliza\";\nimport { stringToUuid } from \"@ai16z/eliza\";\nimport ffmpeg from \"fluent-ffmpeg\";\nimport fs from \"fs\";\nimport path from \"path\";\nimport { tmpdir } from \"os\";\nimport youtubeDl from \"youtube-dl-exec\";\n\nexport class VideoService extends Service implements IVideoService {\n    static serviceType: ServiceType = ServiceType.VIDEO;\n    private cacheKey = \"content/video\";\n    private dataDir = \"./content_cache\";\n\n    private queue: string[] = [];\n    private processing: boolean = false;\n\n    constructor() {\n        super();\n        this.ensureDataDirectoryExists();\n    }\n\n    getInstance(): IVideoService {\n        return VideoService.getInstance();\n    }\n\n    async initialize(runtime: IAgentRuntime): Promise<void> {}\n\n    private ensureDataDirectoryExists() {\n        if (!fs.existsSync(this.dataDir)) {\n            fs.mkdirSync(this.dataDir);\n        }\n    }\n\n    public isVideoUrl(url: string): boolean {\n        return (\n            url.includes(\"youtube.com\") ||\n            url.includes(\"youtu.be\") ||\n            url.includes(\"vimeo.com\")\n        );\n    }\n\n    public async downloadMedia(url: string): Promise<string> {\n        const videoId = this.getVideoId(url);\n        const outputFile = path.join(this.dataDir, `${videoId}.mp4`);\n\n        // if it already exists, return it\n        if (fs.existsSync(outputFile)) {\n            return outputFile;\n        }\n\n        try {\n            await youtubeDl(url, {\n                verbose: true,\n                output: outputFile,\n                writeInfoJson: true,\n            });\n            return outputFile;\n        } catch (error) {\n            console.error(\"Error downloading media:\", error);\n            throw new Error(\"Failed to download media\");\n        }\n    }\n\n    public async downloadVideo(videoInfo: any): Promise<string> {\n        const videoId = this.getVideoId(videoInfo.webpage_url);\n        const outputFile = path.join(this.dataDir, `${videoId}.mp4`);\n\n        // if it already exists, return it\n        if (fs.existsSync(outputFile)) {\n            return outputFile;\n        }\n\n        try {\n            await youtubeDl(videoInfo.webpage_url, {\n                verbose: true,\n                output: outputFile,\n                format: \"bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best\",\n                writeInfoJson: true,\n            });\n            return outputFile;\n        } catch (error) {\n            console.error(\"Error downloading video:\", error);\n            throw new Error(\"Failed to download video\");\n        }\n    }\n\n    public async processVideo(\n        url: string,\n        runtime?: IAgentRuntime\n    ): Promise<Media> {\n        this.queue.push(url);\n        this.processQueue(runtime);\n\n        return new Promise((resolve, reject) => {\n            const checkQueue = async () => {\n                const index = this.queue.indexOf(url);\n                if (index !== -1) {\n                    setTimeout(checkQueue, 100);\n                } else {\n                    try {\n                        const result = await this.processVideoFromUrl(\n                            url,\n                            runtime\n                        );\n                        resolve(result);\n                    } catch (error) {\n                        reject(error);\n                    }\n                }\n            };\n            checkQueue();\n        });\n    }\n\n    private async processQueue(runtime): Promise<void> {\n        if (this.processing || this.queue.length === 0) {\n            return;\n        }\n\n        this.processing = true;\n\n        while (this.queue.length > 0) {\n            const url = this.queue.shift()!;\n            await this.processVideoFromUrl(url, runtime);\n        }\n\n        this.processing = false;\n    }\n\n    private async processVideoFromUrl(\n        url: string,\n        runtime: IAgentRuntime\n    ): Promise<Media> {\n        const videoId =\n            url.match(\n                /(?:youtu\\.be\\/|youtube\\.com(?:\\/embed\\/|\\/v\\/|\\/watch\\?v=|\\/watch\\?.+&v=))([^\\/&?]+)/\n            )?.[1] || \"\";\n        const videoUuid = this.getVideoId(videoId);\n        const cacheKey = `${this.cacheKey}/${videoUuid}`;\n\n        const cached = await runtime.cacheManager.get<Media>(cacheKey);\n\n        if (cached) {\n            console.log(\"Returning cached video file\");\n            return cached;\n        }\n\n        console.log(\"Cache miss, processing video\");\n        console.log(\"Fetching video info\");\n        const videoInfo = await this.fetchVideoInfo(url);\n        console.log(\"Getting transcript\");\n        const transcript = await this.getTranscript(url, videoInfo, runtime);\n\n        const result: Media = {\n            id: videoUuid,\n            url: url,\n            title: videoInfo.title,\n            source: videoInfo.channel,\n            description: videoInfo.description,\n            text: transcript,\n        };\n\n        await runtime.cacheManager.set(cacheKey, result);\n\n        return result;\n    }\n\n    private getVideoId(url: string): string {\n        return stringToUuid(url);\n    }\n\n    async fetchVideoInfo(url: string): Promise<any> {\n        if (url.endsWith(\".mp4\") || url.includes(\".mp4?\")) {\n            try {\n                const response = await fetch(url);\n                if (response.ok) {\n                    // If the URL is a direct link to an MP4 file, return a simplified video info object\n                    return {\n                        title: path.basename(url),\n                        description: \"\",\n                        channel: \"\",\n                    };\n                }\n            } catch (error) {\n                console.error(\"Error downloading MP4 file:\", error);\n                // Fall back to using youtube-dl if direct download fails\n            }\n        }\n\n        try {\n            const result = await youtubeDl(url, {\n                dumpJson: true,\n                verbose: true,\n                callHome: false,\n                noCheckCertificates: true,\n                preferFreeFormats: true,\n                youtubeSkipDashManifest: true,\n                writeSub: true,\n                writeAutoSub: true,\n                subLang: \"en\",\n                skipDownload: true,\n            });\n            return result;\n        } catch (error) {\n            console.error(\"Error fetching video info:\", error);\n            throw new Error(\"Failed to fetch video information\");\n        }\n    }\n\n    private async getTranscript(\n        url: string,\n        videoInfo: any,\n        runtime: IAgentRuntime\n    ): Promise<string> {\n        console.log(\"Getting transcript\");\n        try {\n            // Check for manual subtitles\n            if (videoInfo.subtitles && videoInfo.subtitles.en) {\n                console.log(\"Manual subtitles found\");\n                const srtContent = await this.downloadSRT(\n                    videoInfo.subtitles.en[0].url\n                );\n                return this.parseSRT(srtContent);\n            }\n\n            // Check for automatic captions\n            if (\n                videoInfo.automatic_captions &&\n                videoInfo.automatic_captions.en\n            ) {\n                console.log(\"Automatic captions found\");\n                const captionUrl = videoInfo.automatic_captions.en[0].url;\n                const captionContent = await this.downloadCaption(captionUrl);\n                return this.parseCaption(captionContent);\n            }\n\n            // Check if it's a music video\n            if (\n                videoInfo.categories &&\n                videoInfo.categories.includes(\"Music\")\n            ) {\n                console.log(\"Music video detected, no lyrics available\");\n                return \"No lyrics available.\";\n            }\n\n            // Fall back to audio transcription\n            console.log(\n                \"No captions found, falling back to audio transcription\"\n            );\n            return this.transcribeAudio(url, runtime);\n        } catch (error) {\n            console.error(\"Error in getTranscript:\", error);\n            throw error;\n        }\n    }\n\n    private async downloadCaption(url: string): Promise<string> {\n        console.log(\"Downloading caption from:\", url);\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error(\n                `Failed to download caption: ${response.statusText}`\n            );\n        }\n        return await response.text();\n    }\n\n    private parseCaption(captionContent: string): string {\n        console.log(\"Parsing caption\");\n        try {\n            const jsonContent = JSON.parse(captionContent);\n            if (jsonContent.events) {\n                return jsonContent.events\n                    .filter((event) => event.segs)\n                    .map((event) => event.segs.map((seg) => seg.utf8).join(\"\"))\n                    .join(\"\")\n                    .replace(\"\\n\", \" \");\n            } else {\n                console.error(\"Unexpected caption format:\", jsonContent);\n                return \"Error: Unable to parse captions\";\n            }\n        } catch (error) {\n            console.error(\"Error parsing caption:\", error);\n            return \"Error: Unable to parse captions\";\n        }\n    }\n\n    private parseSRT(srtContent: string): string {\n        // Simple SRT parser (replace with a more robust solution if needed)\n        return srtContent\n            .split(\"\\n\\n\")\n            .map((block) => block.split(\"\\n\").slice(2).join(\" \"))\n            .join(\" \");\n    }\n\n    private async downloadSRT(url: string): Promise<string> {\n        console.log(\"downloadSRT\");\n        const response = await fetch(url);\n        return await response.text();\n    }\n\n    async transcribeAudio(\n        url: string,\n        runtime: IAgentRuntime\n    ): Promise<string> {\n        console.log(\"Preparing audio for transcription...\");\n        const mp4FilePath = path.join(\n            this.dataDir,\n            `${this.getVideoId(url)}.mp4`\n        );\n\n        const mp3FilePath = path.join(\n            this.dataDir,\n            `${this.getVideoId(url)}.mp3`\n        );\n\n        if (!fs.existsSync(mp3FilePath)) {\n            if (fs.existsSync(mp4FilePath)) {\n                console.log(\"MP4 file found. Converting to MP3...\");\n                await this.convertMp4ToMp3(mp4FilePath, mp3FilePath);\n            } else {\n                console.log(\"Downloading audio...\");\n                await this.downloadAudio(url, mp3FilePath);\n            }\n        }\n\n        console.log(`Audio prepared at ${mp3FilePath}`);\n\n        const audioBuffer = fs.readFileSync(mp3FilePath);\n        console.log(`Audio file size: ${audioBuffer.length} bytes`);\n\n        console.log(\"Starting transcription...\");\n        const startTime = Date.now();\n        const transcriptionService = runtime.getService<ITranscriptionService>(\n            ServiceType.TRANSCRIPTION\n        );\n\n        if (!transcriptionService) {\n            throw new Error(\"Transcription service not found\");\n        }\n\n        const transcript = await transcriptionService.transcribe(audioBuffer);\n\n        const endTime = Date.now();\n        console.log(\n            `Transcription completed in ${(endTime - startTime) / 1000} seconds`\n        );\n\n        // Don't delete the MP3 file as it might be needed for future use\n        return transcript || \"Transcription failed\";\n    }\n\n    private async convertMp4ToMp3(\n        inputPath: string,\n        outputPath: string\n    ): Promise<void> {\n        return new Promise((resolve, reject) => {\n            ffmpeg(inputPath)\n                .output(outputPath)\n                .noVideo()\n                .audioCodec(\"libmp3lame\")\n                .on(\"end\", () => {\n                    console.log(\"Conversion to MP3 complete\");\n                    resolve();\n                })\n                .on(\"error\", (err) => {\n                    console.error(\"Error converting to MP3:\", err);\n                    reject(err);\n                })\n                .run();\n        });\n    }\n\n    private async downloadAudio(\n        url: string,\n        outputFile: string\n    ): Promise<string> {\n        console.log(\"Downloading audio\");\n        outputFile =\n            outputFile ??\n            path.join(this.dataDir, `${this.getVideoId(url)}.mp3`);\n\n        try {\n            if (url.endsWith(\".mp4\") || url.includes(\".mp4?\")) {\n                console.log(\n                    \"Direct MP4 file detected, downloading and converting to MP3\"\n                );\n                const tempMp4File = path.join(\n                    tmpdir(),\n                    `${this.getVideoId(url)}.mp4`\n                );\n                const response = await fetch(url);\n                const arrayBuffer = await response.arrayBuffer();\n                const buffer = Buffer.from(arrayBuffer);\n                fs.writeFileSync(tempMp4File, buffer);\n\n                await new Promise<void>((resolve, reject) => {\n                    ffmpeg(tempMp4File)\n                        .output(outputFile)\n                        .noVideo()\n                        .audioCodec(\"libmp3lame\")\n                        .on(\"end\", () => {\n                            fs.unlinkSync(tempMp4File);\n                            resolve();\n                        })\n                        .on(\"error\", (err) => {\n                            reject(err);\n                        })\n                        .run();\n                });\n            } else {\n                console.log(\n                    \"YouTube video detected, downloading audio with youtube-dl\"\n                );\n                await youtubeDl(url, {\n                    verbose: true,\n                    extractAudio: true,\n                    audioFormat: \"mp3\",\n                    output: outputFile,\n                    writeInfoJson: true,\n                });\n            }\n            return outputFile;\n        } catch (error) {\n            console.error(\"Error downloading audio:\", error);\n            throw new Error(\"Failed to download audio\");\n        }\n    }\n}\n","export * from \"./services/index.ts\";\n\nimport { Plugin } from \"@ai16z/eliza\";\n\nimport {\n    BrowserService,\n    ImageDescriptionService,\n    LlamaService,\n    PdfService,\n    SpeechService,\n    TranscriptionService,\n    VideoService,\n} from \"./services/index.ts\";\n\nexport const nodePlugin: Plugin = {\n    name: \"default\",\n    description: \"Default plugin, with basic actions and evaluators\",\n    services: [\n        new BrowserService(),\n        new ImageDescriptionService(),\n        new LlamaService(),\n        new PdfService(),\n        new SpeechService(),\n        new TranscriptionService(),\n        new VideoService(),\n    ],\n};\n\nexport default nodePlugin;\n"],"mappings":"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","names":["Service","ServiceType","elizaLogger","ServiceType","Service","fs","path","Service","ServiceType","ServiceType","Service","Service","ServiceType","elizaLogger","settings","Service","ServiceType","fs","os","path","fileURLToPath","__dirname","Service","ServiceType","stringToUuid","fs","path"]}