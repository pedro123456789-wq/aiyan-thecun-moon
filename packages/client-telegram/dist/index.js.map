{"version":3,"sources":["../src/index.ts","../src/telegramClient.ts","../src/messageManager.ts","../src/enviroment.ts"],"sourcesContent":["import { elizaLogger } from \"@ai16z/eliza\";\nimport { Client, IAgentRuntime } from \"@ai16z/eliza\";\nimport { TelegramClient } from \"./telegramClient.ts\";\nimport { validateTelegramConfig } from \"./enviroment.ts\";\n\nexport const TelegramClientInterface: Client = {\n    start: async (runtime: IAgentRuntime) => {\n        await validateTelegramConfig(runtime);\n\n        const tg = new TelegramClient(\n            runtime,\n            runtime.getSetting(\"TELEGRAM_BOT_TOKEN\")\n        );\n\n        await tg.start();\n\n        elizaLogger.success(\n            `‚úÖ Telegram client successfully started for character ${runtime.character.name}`\n        );\n        return tg;\n    },\n    stop: async (runtime: IAgentRuntime) => {\n        console.warn(\"Telegram client does not support stopping yet\");\n    },\n};\n\nexport default TelegramClientInterface;\n","import { Context, Telegraf } from \"telegraf\";\n\nimport { IAgentRuntime } from \"@ai16z/eliza\";\nimport { MessageManager } from \"./messageManager.ts\";\nimport { elizaLogger } from \"@ai16z/eliza\";\n\nexport class TelegramClient {\n    private bot: Telegraf<Context>;\n    private runtime: IAgentRuntime;\n    private messageManager: MessageManager;\n\n    constructor(runtime: IAgentRuntime, botToken: string) {\n        elizaLogger.log(\"üì± Constructing new TelegramClient...\");\n        this.runtime = runtime;\n        this.bot = new Telegraf(botToken);\n        this.messageManager = new MessageManager(this.bot, this.runtime);\n\n        elizaLogger.log(\"‚úÖ TelegramClient constructor completed\");\n    }\n\n    public async start(): Promise<void> {\n        elizaLogger.log(\"üöÄ Starting Telegram bot...\");\n        try {\n            this.bot.launch({\n                dropPendingUpdates: true,\n            });\n            elizaLogger.log(\n                \"‚ú® Telegram bot successfully launched and is running!\"\n            );\n\n            await this.bot.telegram.getMe().then((botInfo) => {\n                this.bot.botInfo = botInfo;\n            });\n\n            elizaLogger.success(`Bot username: @${this.bot.botInfo?.username}`);\n\n            this.messageManager.bot = this.bot;\n\n            // Include if you want to view message maanger bot info\n            // console.log(`Message Manager bot info: @${this.messageManager.bot}`);\n\n            elizaLogger.log(\"Setting up message handler...\");\n\n            this.bot.on(\"message\", async (ctx) => {\n                try {\n                    // console.log(\"üì• Received message:\", ctx.message);\n                    await this.messageManager.handleMessage(ctx);\n                } catch (error) {\n                    elizaLogger.error(\"‚ùå Error handling message:\", error);\n                    await ctx.reply(\n                        \"An error occurred while processing your message.\"\n                    );\n                }\n            });\n\n            // Handle specific message types for better logging\n            this.bot.on(\"photo\", (ctx) => {\n                elizaLogger.log(\n                    \"üì∏ Received photo message with caption:\",\n                    ctx.message.caption\n                );\n            });\n\n            this.bot.on(\"document\", (ctx) => {\n                elizaLogger.log(\n                    \"üìé Received document message:\",\n                    ctx.message.document.file_name\n                );\n            });\n\n            this.bot.catch((err, ctx) => {\n                elizaLogger.error(\n                    `‚ùå Telegram Error for ${ctx.updateType}:`,\n                    err\n                );\n                ctx.reply(\n                    \"An unexpected error occurred. Please try again later.\"\n                );\n            });\n\n            // Graceful shutdown handlers\n            const shutdownHandler = async (signal: string) => {\n                elizaLogger.log(\n                    `‚ö†Ô∏è Received ${signal}. Shutting down Telegram bot gracefully...`\n                );\n                try {\n                    await this.stop();\n                    elizaLogger.log(\"üõë Telegram bot stopped gracefully\");\n                } catch (error) {\n                    elizaLogger.error(\n                        \"‚ùå Error during Telegram bot shutdown:\",\n                        error\n                    );\n                    throw error;\n                }\n            };\n\n            process.once(\"SIGINT\", () => shutdownHandler(\"SIGINT\"));\n            process.once(\"SIGTERM\", () => shutdownHandler(\"SIGTERM\"));\n            process.once(\"SIGHUP\", () => shutdownHandler(\"SIGHUP\"));\n        } catch (error) {\n            elizaLogger.error(\"‚ùå Failed to launch Telegram bot:\", error);\n            throw error;\n        }\n    }\n\n    public async stop(): Promise<void> {\n        elizaLogger.log(\"Stopping Telegram bot...\");\n        await this.bot.stop();\n        elizaLogger.log(\"Telegram bot stopped\");\n    }\n}\n","import { Message } from \"@telegraf/types\";\nimport { Context, Telegraf } from \"telegraf\";\n\nimport { composeContext } from \"@ai16z/eliza\";\nimport { embeddingZeroVector } from \"@ai16z/eliza\";\nimport {\n    Content,\n    HandlerCallback,\n    IAgentRuntime,\n    IImageDescriptionService,\n    Memory,\n    ModelClass,\n    State,\n    UUID,\n} from \"@ai16z/eliza\";\nimport { stringToUuid } from \"@ai16z/eliza\";\n\nimport { generateMessageResponse, generateShouldRespond } from \"@ai16z/eliza\";\nimport { messageCompletionFooter, shouldRespondFooter } from \"@ai16z/eliza\";\nimport { ImageDescriptionService } from \"@ai16z/plugin-node\";\n\nconst MAX_MESSAGE_LENGTH = 4096; // Telegram's max message length\n\nconst telegramShouldRespondTemplate =\n    `# About {{agentName}}:\n{{bio}}\n\n# RESPONSE EXAMPLES\n{{user1}}: I just saw a really great movie\n{{user2}}: Oh? Which movie?\nResult: [IGNORE]\n\n{{agentName}}: Oh, this is my favorite scene\n{{user1}}: sick\n{{user2}}: wait, why is it your favorite scene\nResult: [RESPOND]\n\n{{user1}}: stfu bot\nResult: [STOP]\n\n{{user1}}: Hey {{agent}}, can you help me with something\nResult: [RESPOND]\n\n{{user1}}: {{agentName}} stfu plz\nResult: [STOP]\n\n{{user1}}: i need help\n{{agentName}}: how can I help you?\n{{user1}}: no. i need help from someone else\nResult: [IGNORE]\n\n{{user1}}: Hey {{agent}}, can I ask you a question\n{{agentName}}: Sure, what is it\n{{user1}}: can you ask claude to create a basic react module that demonstrates a counter\nResult: [RESPOND]\n\n{{user1}}: {{agentName}} can you tell me a story\n{{agentName}}: uhhh...\n{{user1}}: please do it\n{{agentName}}: okay\n{{agentName}}: once upon a time, in a quaint little village, there was a curious girl named elara\n{{user1}}: I'm loving it, keep going\nResult: [RESPOND]\n\n{{user1}}: {{agentName}} stop responding plz\nResult: [STOP]\n\n{{user1}}: okay, i want to test something. {{agentName}}, can you say marco?\n{{agentName}}: marco\n{{user1}}: great. okay, now do it again\nResult: [RESPOND]\n\nResponse options are [RESPOND], [IGNORE] and [STOP].\n\n{{agentName}} is in a room with other users and should only respond when they are being addressed, and should not respond if they are continuing a conversation that is very long.\n\nRespond with [RESPOND] to messages that are directed at {{agentName}}, or participate in conversations that are interesting or relevant to their background.\nIf a message is not interesting, relevant, or does not directly address {{agentName}}, respond with [IGNORE]\n\nAlso, respond with [IGNORE] to messages that are very short or do not contain much information.\n\nIf a user asks {{agentName}} to be quiet, respond with [STOP]\nIf {{agentName}} concludes a conversation and isn't part of the conversation anymore, respond with [STOP]\n\nIMPORTANT: {{agentName}} is particularly sensitive about being annoying, so if there is any doubt, it is better to respond with [IGNORE].\nIf {{agentName}} is conversing with a user and they have not asked to stop, it is better to respond with [RESPOND].\n\nThe goal is to decide whether {{agentName}} should respond to the last message.\n\n{{recentMessages}}\n\nThread of Tweets You Are Replying To:\n\n{{formattedConversation}}\n\n# INSTRUCTIONS: Choose the option that best describes {{agentName}}'s response to the last message. Ignore messages if they are addressed to someone else.\n` + shouldRespondFooter;\n\nconst telegramMessageHandlerTemplate =\n    // {{goals}}\n    `# Action Examples\n{{actionExamples}}\n(Action examples are for reference only. Do not use the information from them in your response.)\n\n# Knowledge\n{{knowledge}}\n\n# Task: Generate dialog and actions for the character {{agentName}}.\nAbout {{agentName}}:\n{{bio}}\n{{lore}}\n\nExamples of {{agentName}}'s dialog and actions:\n{{characterMessageExamples}}\n\n{{providers}}\n\n{{attachments}}\n\n{{actions}}\n\n# Capabilities\nNote that {{agentName}} is capable of reading/seeing/hearing various forms of media, including images, videos, audio, plaintext and PDFs. Recent attachments have been included above under the \"Attachments\" section.\n\n{{messageDirections}}\n\n{{recentMessages}}\n\n# Task: Generate a post/reply in the voice, style and perspective of {{agentName}} (@{{twitterUserName}}) while using the thread of tweets as additional context:\nCurrent Post:\n{{currentPost}}\nThread of Tweets You Are Replying To:\n\n{{formattedConversation}}\n` + messageCompletionFooter;\n\nexport class MessageManager {\n    public bot: Telegraf<Context>;\n    private runtime: IAgentRuntime;\n    private imageService: IImageDescriptionService;\n\n    constructor(bot: Telegraf<Context>, runtime: IAgentRuntime) {\n        this.bot = bot;\n        this.runtime = runtime;\n        this.imageService = ImageDescriptionService.getInstance();\n    }\n\n    // Process image messages and generate descriptions\n    private async processImage(\n        message: Message\n    ): Promise<{ description: string } | null> {\n        // console.log(\n        //     \"üñºÔ∏è Processing image message:\",\n        //     JSON.stringify(message, null, 2)\n        // );\n\n        try {\n            let imageUrl: string | null = null;\n\n            // Handle photo messages\n            if (\"photo\" in message && message.photo?.length > 0) {\n                const photo = message.photo[message.photo.length - 1];\n                const fileLink = await this.bot.telegram.getFileLink(\n                    photo.file_id\n                );\n                imageUrl = fileLink.toString();\n            }\n            // Handle image documents\n            else if (\n                \"document\" in message &&\n                message.document?.mime_type?.startsWith(\"image/\")\n            ) {\n                const doc = message.document;\n                const fileLink = await this.bot.telegram.getFileLink(\n                    doc.file_id\n                );\n                imageUrl = fileLink.toString();\n            }\n\n            if (imageUrl) {\n                const { title, description } =\n                    await this.imageService.describeImage(imageUrl);\n                const fullDescription = `[Image: ${title}\\n${description}]`;\n                return { description: fullDescription };\n            }\n        } catch (error) {\n            console.error(\"‚ùå Error processing image:\", error);\n        }\n\n        return null; // No image found\n    }\n\n    // Decide if the bot should respond to the message\n    private async _shouldRespond(\n        message: Message,\n        state: State\n    ): Promise<boolean> {\n        // Respond if bot is mentioned\n\n        if (\n            \"text\" in message &&\n            message.text?.includes(`@${this.bot.botInfo?.username}`)\n        ) {\n            return true;\n        }\n\n        // Respond to private chats\n        if (message.chat.type === \"private\") {\n            return true;\n        }\n\n        // Respond to images in group chats\n        if (\n            \"photo\" in message ||\n            (\"document\" in message &&\n                message.document?.mime_type?.startsWith(\"image/\"))\n        ) {\n            return false;\n        }\n\n        // Use AI to decide for text or captions\n        if (\"text\" in message || (\"caption\" in message && message.caption)) {\n            const shouldRespondContext = composeContext({\n                state,\n                template:\n                    this.runtime.character.templates\n                        ?.telegramShouldRespondTemplate ||\n                    this.runtime.character?.templates?.shouldRespondTemplate ||\n                    telegramShouldRespondTemplate,\n            });\n\n            const response = await generateShouldRespond({\n                runtime: this.runtime,\n                context: shouldRespondContext,\n                modelClass: ModelClass.SMALL,\n            });\n\n            return response === \"RESPOND\";\n        }\n\n        return false; // No criteria met\n    }\n\n    // Send long messages in chunks\n    private async sendMessageInChunks(\n        ctx: Context,\n        content: string,\n        replyToMessageId?: number\n    ): Promise<Message.TextMessage[]> {\n        const chunks = this.splitMessage(content);\n        const sentMessages: Message.TextMessage[] = [];\n\n        for (let i = 0; i < chunks.length; i++) {\n            const chunk = chunks[i];\n            const sentMessage = (await ctx.telegram.sendMessage(\n                ctx.chat.id,\n                chunk,\n                {\n                    reply_parameters:\n                        i === 0 && replyToMessageId\n                            ? { message_id: replyToMessageId }\n                            : undefined,\n                }\n            )) as Message.TextMessage;\n\n            sentMessages.push(sentMessage);\n        }\n\n        return sentMessages;\n    }\n\n    // Split message into smaller parts\n    private splitMessage(text: string): string[] {\n        const chunks: string[] = [];\n        let currentChunk = \"\";\n\n        const lines = text.split(\"\\n\");\n        for (const line of lines) {\n            if (currentChunk.length + line.length + 1 <= MAX_MESSAGE_LENGTH) {\n                currentChunk += (currentChunk ? \"\\n\" : \"\") + line;\n            } else {\n                if (currentChunk) chunks.push(currentChunk);\n                currentChunk = line;\n            }\n        }\n\n        if (currentChunk) chunks.push(currentChunk);\n        return chunks;\n    }\n\n    // Generate a response using AI\n    private async _generateResponse(\n        message: Memory,\n        state: State,\n        context: string\n    ): Promise<Content> {\n        const { userId, roomId } = message;\n\n        const response = await generateMessageResponse({\n            runtime: this.runtime,\n            context,\n            modelClass: ModelClass.SMALL,\n        });\n\n        if (!response) {\n            console.error(\"‚ùå No response from generateMessageResponse\");\n            return null;\n        }\n        await this.runtime.databaseAdapter.log({\n            body: { message, context, response },\n            userId: userId,\n            roomId,\n            type: \"response\",\n        });\n\n        return response;\n    }\n\n    // Main handler for incoming messages\n    public async handleMessage(ctx: Context): Promise<void> {\n        if (!ctx.message || !ctx.from) {\n            return; // Exit if no message or sender info\n        }\n\n        if (\n            this.runtime.character.clientConfig?.telegram\n                ?.shouldIgnoreBotMessages &&\n            ctx.from.is_bot\n        ) {\n            return;\n        }\n        if (\n            this.runtime.character.clientConfig?.telegram\n                ?.shouldIgnoreDirectMessages &&\n            ctx.chat?.type === \"private\"\n        ) {\n            return;\n        }\n\n        const message = ctx.message;\n\n        try {\n            // Convert IDs to UUIDs\n            const userId = stringToUuid(ctx.from.id.toString()) as UUID;\n            const userName =\n                ctx.from.username || ctx.from.first_name || \"Unknown User\";\n            const chatId = stringToUuid(\n                ctx.chat?.id.toString() + \"-\" + this.runtime.agentId\n            ) as UUID;\n            const agentId = this.runtime.agentId;\n            const roomId = chatId;\n\n            await this.runtime.ensureConnection(\n                userId,\n                roomId,\n                userName,\n                userName,\n                \"telegram\"\n            );\n\n            const messageId = stringToUuid(\n                message.message_id.toString() + \"-\" + this.runtime.agentId\n            ) as UUID;\n\n            // Handle images\n            const imageInfo = await this.processImage(message);\n\n            // Get text or caption\n            let messageText = \"\";\n            if (\"text\" in message) {\n                messageText = message.text;\n            } else if (\"caption\" in message && message.caption) {\n                messageText = message.caption;\n            }\n\n            // Combine text and image description\n            const fullText = imageInfo\n                ? `${messageText} ${imageInfo.description}`\n                : messageText;\n\n            if (!fullText) {\n                return; // Skip if no content\n            }\n\n            const content: Content = {\n                text: fullText,\n                source: \"telegram\",\n                // inReplyTo:\n                //     \"reply_to_message\" in message && message.reply_to_message\n                //         ? stringToUuid(\n                //               message.reply_to_message.message_id.toString() +\n                //                   \"-\" +\n                //                   this.runtime.agentId\n                //           )\n                //         : undefined,\n            };\n\n            // Create memory for the message\n            const memory: Memory = {\n                id: messageId,\n                agentId,\n                userId,\n                roomId,\n                content,\n                createdAt: message.date * 1000,\n                embedding: embeddingZeroVector,\n            };\n\n            await this.runtime.messageManager.createMemory(memory);\n\n            // Update state with the new memory\n            let state = await this.runtime.composeState(memory);\n            state = await this.runtime.updateRecentMessageState(state);\n\n            // Decide whether to respond\n            const shouldRespond = await this._shouldRespond(message, state);\n\n            if (shouldRespond) {\n                // Generate response\n                const context = composeContext({\n                    state,\n                    template:\n                        this.runtime.character.templates\n                            ?.telegramMessageHandlerTemplate ||\n                        this.runtime.character?.templates\n                            ?.messageHandlerTemplate ||\n                        telegramMessageHandlerTemplate,\n                });\n\n                const responseContent = await this._generateResponse(\n                    memory,\n                    state,\n                    context\n                );\n\n                if (!responseContent || !responseContent.text) return;\n\n                // Send response in chunks\n                const callback: HandlerCallback = async (content: Content) => {\n                    const sentMessages = await this.sendMessageInChunks(\n                        ctx,\n                        content.text,\n                        message.message_id\n                    );\n\n                    const memories: Memory[] = [];\n\n                    // Create memories for each sent message\n                    for (let i = 0; i < sentMessages.length; i++) {\n                        const sentMessage = sentMessages[i];\n                        const isLastMessage = i === sentMessages.length - 1;\n\n                        const memory: Memory = {\n                            id: stringToUuid(\n                                sentMessage.message_id.toString() +\n                                    \"-\" +\n                                    this.runtime.agentId\n                            ),\n                            agentId,\n                            userId,\n                            roomId,\n                            content: {\n                                ...content,\n                                text: sentMessage.text,\n                                inReplyTo: messageId,\n                            },\n                            createdAt: sentMessage.date * 1000,\n                            embedding: embeddingZeroVector,\n                        };\n\n                        // Set action to CONTINUE for all messages except the last one\n                        // For the last message, use the original action from the response content\n                        memory.content.action = !isLastMessage\n                            ? \"CONTINUE\"\n                            : content.action;\n\n                        await this.runtime.messageManager.createMemory(memory);\n                        memories.push(memory);\n                    }\n\n                    return memories;\n                };\n\n                // Execute callback to send messages and log memories\n                const responseMessages = await callback(responseContent);\n\n                // Update state after response\n                state = await this.runtime.updateRecentMessageState(state);\n\n                // Handle any resulting actions\n                await this.runtime.processActions(\n                    memory,\n                    responseMessages,\n                    state,\n                    callback\n                );\n            }\n\n            await this.runtime.evaluate(memory, state, shouldRespond);\n        } catch (error) {\n            console.error(\"‚ùå Error handling message:\", error);\n            console.error(\"Error sending message:\", error);\n        }\n    }\n}\n","import { IAgentRuntime } from \"@ai16z/eliza\";\nimport { z } from \"zod\";\n\nexport const telegramEnvSchema = z.object({\n    TELEGRAM_BOT_TOKEN: z.string().min(1, \"Telegram bot token is required\"),\n});\n\nexport type TelegramConfig = z.infer<typeof telegramEnvSchema>;\n\nexport async function validateTelegramConfig(\n    runtime: IAgentRuntime\n): Promise<TelegramConfig> {\n    try {\n        const config = {\n            TELEGRAM_BOT_TOKEN:\n                runtime.getSetting(\"TELEGRAM_BOT_TOKEN\") ||\n                process.env.TELEGRAM_BOT_TOKEN,\n        };\n\n        return telegramEnvSchema.parse(config);\n    } catch (error) {\n        if (error instanceof z.ZodError) {\n            const errorMessages = error.errors\n                .map((err) => `${err.path.join(\".\")}: ${err.message}`)\n                .join(\"\\n\");\n            throw new Error(\n                `Telegram configuration validation failed:\\n${errorMessages}`\n            );\n        }\n        throw error;\n    }\n}\n"],"mappings":";AAAA,SAAS,eAAAA,oBAAmB;;;ACA5B,SAAkB,gBAAgB;;;ACGlC,SAAS,sBAAsB;AAC/B,SAAS,2BAA2B;AACpC;AAAA,EAMI;AAAA,OAGG;AACP,SAAS,oBAAoB;AAE7B,SAAS,yBAAyB,6BAA6B;AAC/D,SAAS,yBAAyB,2BAA2B;AAC7D,SAAS,+BAA+B;AAExC,IAAM,qBAAqB;AAE3B,IAAM,gCACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAwEA;AAEJ,IAAM;AAAA;AAAA,EAEF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAkCA;AAAA;AAEG,IAAM,iBAAN,MAAqB;AAAA,EACjB;AAAA,EACC;AAAA,EACA;AAAA,EAER,YAAY,KAAwB,SAAwB;AACxD,SAAK,MAAM;AACX,SAAK,UAAU;AACf,SAAK,eAAe,wBAAwB,YAAY;AAAA,EAC5D;AAAA;AAAA,EAGA,MAAc,aACV,SACuC;AAMvC,QAAI;AACA,UAAI,WAA0B;AAG9B,UAAI,WAAW,WAAW,QAAQ,OAAO,SAAS,GAAG;AACjD,cAAM,QAAQ,QAAQ,MAAM,QAAQ,MAAM,SAAS,CAAC;AACpD,cAAM,WAAW,MAAM,KAAK,IAAI,SAAS;AAAA,UACrC,MAAM;AAAA,QACV;AACA,mBAAW,SAAS,SAAS;AAAA,MACjC,WAGI,cAAc,WACd,QAAQ,UAAU,WAAW,WAAW,QAAQ,GAClD;AACE,cAAM,MAAM,QAAQ;AACpB,cAAM,WAAW,MAAM,KAAK,IAAI,SAAS;AAAA,UACrC,IAAI;AAAA,QACR;AACA,mBAAW,SAAS,SAAS;AAAA,MACjC;AAEA,UAAI,UAAU;AACV,cAAM,EAAE,OAAO,YAAY,IACvB,MAAM,KAAK,aAAa,cAAc,QAAQ;AAClD,cAAM,kBAAkB,WAAW,KAAK;AAAA,EAAK,WAAW;AACxD,eAAO,EAAE,aAAa,gBAAgB;AAAA,MAC1C;AAAA,IACJ,SAAS,OAAO;AACZ,cAAQ,MAAM,kCAA6B,KAAK;AAAA,IACpD;AAEA,WAAO;AAAA,EACX;AAAA;AAAA,EAGA,MAAc,eACV,SACA,OACgB;AAGhB,QACI,UAAU,WACV,QAAQ,MAAM,SAAS,IAAI,KAAK,IAAI,SAAS,QAAQ,EAAE,GACzD;AACE,aAAO;AAAA,IACX;AAGA,QAAI,QAAQ,KAAK,SAAS,WAAW;AACjC,aAAO;AAAA,IACX;AAGA,QACI,WAAW,WACV,cAAc,WACX,QAAQ,UAAU,WAAW,WAAW,QAAQ,GACtD;AACE,aAAO;AAAA,IACX;AAGA,QAAI,UAAU,WAAY,aAAa,WAAW,QAAQ,SAAU;AAChE,YAAM,uBAAuB,eAAe;AAAA,QACxC;AAAA,QACA,UACI,KAAK,QAAQ,UAAU,WACjB,iCACN,KAAK,QAAQ,WAAW,WAAW,yBACnC;AAAA,MACR,CAAC;AAED,YAAM,WAAW,MAAM,sBAAsB;AAAA,QACzC,SAAS,KAAK;AAAA,QACd,SAAS;AAAA,QACT,YAAY,WAAW;AAAA,MAC3B,CAAC;AAED,aAAO,aAAa;AAAA,IACxB;AAEA,WAAO;AAAA,EACX;AAAA;AAAA,EAGA,MAAc,oBACV,KACA,SACA,kBAC8B;AAC9B,UAAM,SAAS,KAAK,aAAa,OAAO;AACxC,UAAM,eAAsC,CAAC;AAE7C,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACpC,YAAM,QAAQ,OAAO,CAAC;AACtB,YAAM,cAAe,MAAM,IAAI,SAAS;AAAA,QACpC,IAAI,KAAK;AAAA,QACT;AAAA,QACA;AAAA,UACI,kBACI,MAAM,KAAK,mBACL,EAAE,YAAY,iBAAiB,IAC/B;AAAA,QACd;AAAA,MACJ;AAEA,mBAAa,KAAK,WAAW;AAAA,IACjC;AAEA,WAAO;AAAA,EACX;AAAA;AAAA,EAGQ,aAAa,MAAwB;AACzC,UAAM,SAAmB,CAAC;AAC1B,QAAI,eAAe;AAEnB,UAAM,QAAQ,KAAK,MAAM,IAAI;AAC7B,eAAW,QAAQ,OAAO;AACtB,UAAI,aAAa,SAAS,KAAK,SAAS,KAAK,oBAAoB;AAC7D,yBAAiB,eAAe,OAAO,MAAM;AAAA,MACjD,OAAO;AACH,YAAI,aAAc,QAAO,KAAK,YAAY;AAC1C,uBAAe;AAAA,MACnB;AAAA,IACJ;AAEA,QAAI,aAAc,QAAO,KAAK,YAAY;AAC1C,WAAO;AAAA,EACX;AAAA;AAAA,EAGA,MAAc,kBACV,SACA,OACA,SACgB;AAChB,UAAM,EAAE,QAAQ,OAAO,IAAI;AAE3B,UAAM,WAAW,MAAM,wBAAwB;AAAA,MAC3C,SAAS,KAAK;AAAA,MACd;AAAA,MACA,YAAY,WAAW;AAAA,IAC3B,CAAC;AAED,QAAI,CAAC,UAAU;AACX,cAAQ,MAAM,iDAA4C;AAC1D,aAAO;AAAA,IACX;AACA,UAAM,KAAK,QAAQ,gBAAgB,IAAI;AAAA,MACnC,MAAM,EAAE,SAAS,SAAS,SAAS;AAAA,MACnC;AAAA,MACA;AAAA,MACA,MAAM;AAAA,IACV,CAAC;AAED,WAAO;AAAA,EACX;AAAA;AAAA,EAGA,MAAa,cAAc,KAA6B;AACpD,QAAI,CAAC,IAAI,WAAW,CAAC,IAAI,MAAM;AAC3B;AAAA,IACJ;AAEA,QACI,KAAK,QAAQ,UAAU,cAAc,UAC/B,2BACN,IAAI,KAAK,QACX;AACE;AAAA,IACJ;AACA,QACI,KAAK,QAAQ,UAAU,cAAc,UAC/B,8BACN,IAAI,MAAM,SAAS,WACrB;AACE;AAAA,IACJ;AAEA,UAAM,UAAU,IAAI;AAEpB,QAAI;AAEA,YAAM,SAAS,aAAa,IAAI,KAAK,GAAG,SAAS,CAAC;AAClD,YAAM,WACF,IAAI,KAAK,YAAY,IAAI,KAAK,cAAc;AAChD,YAAM,SAAS;AAAA,QACX,IAAI,MAAM,GAAG,SAAS,IAAI,MAAM,KAAK,QAAQ;AAAA,MACjD;AACA,YAAM,UAAU,KAAK,QAAQ;AAC7B,YAAM,SAAS;AAEf,YAAM,KAAK,QAAQ;AAAA,QACf;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACJ;AAEA,YAAM,YAAY;AAAA,QACd,QAAQ,WAAW,SAAS,IAAI,MAAM,KAAK,QAAQ;AAAA,MACvD;AAGA,YAAM,YAAY,MAAM,KAAK,aAAa,OAAO;AAGjD,UAAI,cAAc;AAClB,UAAI,UAAU,SAAS;AACnB,sBAAc,QAAQ;AAAA,MAC1B,WAAW,aAAa,WAAW,QAAQ,SAAS;AAChD,sBAAc,QAAQ;AAAA,MAC1B;AAGA,YAAM,WAAW,YACX,GAAG,WAAW,IAAI,UAAU,WAAW,KACvC;AAEN,UAAI,CAAC,UAAU;AACX;AAAA,MACJ;AAEA,YAAM,UAAmB;AAAA,QACrB,MAAM;AAAA,QACN,QAAQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MASZ;AAGA,YAAM,SAAiB;AAAA,QACnB,IAAI;AAAA,QACJ;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA,WAAW,QAAQ,OAAO;AAAA,QAC1B,WAAW;AAAA,MACf;AAEA,YAAM,KAAK,QAAQ,eAAe,aAAa,MAAM;AAGrD,UAAI,QAAQ,MAAM,KAAK,QAAQ,aAAa,MAAM;AAClD,cAAQ,MAAM,KAAK,QAAQ,yBAAyB,KAAK;AAGzD,YAAM,gBAAgB,MAAM,KAAK,eAAe,SAAS,KAAK;AAE9D,UAAI,eAAe;AAEf,cAAM,UAAU,eAAe;AAAA,UAC3B;AAAA,UACA,UACI,KAAK,QAAQ,UAAU,WACjB,kCACN,KAAK,QAAQ,WAAW,WAClB,0BACN;AAAA,QACR,CAAC;AAED,cAAM,kBAAkB,MAAM,KAAK;AAAA,UAC/B;AAAA,UACA;AAAA,UACA;AAAA,QACJ;AAEA,YAAI,CAAC,mBAAmB,CAAC,gBAAgB,KAAM;AAG/C,cAAM,WAA4B,OAAOC,aAAqB;AAC1D,gBAAM,eAAe,MAAM,KAAK;AAAA,YAC5B;AAAA,YACAA,SAAQ;AAAA,YACR,QAAQ;AAAA,UACZ;AAEA,gBAAM,WAAqB,CAAC;AAG5B,mBAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,KAAK;AAC1C,kBAAM,cAAc,aAAa,CAAC;AAClC,kBAAM,gBAAgB,MAAM,aAAa,SAAS;AAElD,kBAAMC,UAAiB;AAAA,cACnB,IAAI;AAAA,gBACA,YAAY,WAAW,SAAS,IAC5B,MACA,KAAK,QAAQ;AAAA,cACrB;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,cACA,SAAS;AAAA,gBACL,GAAGD;AAAA,gBACH,MAAM,YAAY;AAAA,gBAClB,WAAW;AAAA,cACf;AAAA,cACA,WAAW,YAAY,OAAO;AAAA,cAC9B,WAAW;AAAA,YACf;AAIA,YAAAC,QAAO,QAAQ,SAAS,CAAC,gBACnB,aACAD,SAAQ;AAEd,kBAAM,KAAK,QAAQ,eAAe,aAAaC,OAAM;AACrD,qBAAS,KAAKA,OAAM;AAAA,UACxB;AAEA,iBAAO;AAAA,QACX;AAGA,cAAM,mBAAmB,MAAM,SAAS,eAAe;AAGvD,gBAAQ,MAAM,KAAK,QAAQ,yBAAyB,KAAK;AAGzD,cAAM,KAAK,QAAQ;AAAA,UACf;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACJ;AAAA,MACJ;AAEA,YAAM,KAAK,QAAQ,SAAS,QAAQ,OAAO,aAAa;AAAA,IAC5D,SAAS,OAAO;AACZ,cAAQ,MAAM,kCAA6B,KAAK;AAChD,cAAQ,MAAM,0BAA0B,KAAK;AAAA,IACjD;AAAA,EACJ;AACJ;;;ADpfA,SAAS,mBAAmB;AAErB,IAAM,iBAAN,MAAqB;AAAA,EAChB;AAAA,EACA;AAAA,EACA;AAAA,EAER,YAAY,SAAwB,UAAkB;AAClD,gBAAY,IAAI,8CAAuC;AACvD,SAAK,UAAU;AACf,SAAK,MAAM,IAAI,SAAS,QAAQ;AAChC,SAAK,iBAAiB,IAAI,eAAe,KAAK,KAAK,KAAK,OAAO;AAE/D,gBAAY,IAAI,6CAAwC;AAAA,EAC5D;AAAA,EAEA,MAAa,QAAuB;AAChC,gBAAY,IAAI,oCAA6B;AAC7C,QAAI;AACA,WAAK,IAAI,OAAO;AAAA,QACZ,oBAAoB;AAAA,MACxB,CAAC;AACD,kBAAY;AAAA,QACR;AAAA,MACJ;AAEA,YAAM,KAAK,IAAI,SAAS,MAAM,EAAE,KAAK,CAAC,YAAY;AAC9C,aAAK,IAAI,UAAU;AAAA,MACvB,CAAC;AAED,kBAAY,QAAQ,kBAAkB,KAAK,IAAI,SAAS,QAAQ,EAAE;AAElE,WAAK,eAAe,MAAM,KAAK;AAK/B,kBAAY,IAAI,+BAA+B;AAE/C,WAAK,IAAI,GAAG,WAAW,OAAO,QAAQ;AAClC,YAAI;AAEA,gBAAM,KAAK,eAAe,cAAc,GAAG;AAAA,QAC/C,SAAS,OAAO;AACZ,sBAAY,MAAM,kCAA6B,KAAK;AACpD,gBAAM,IAAI;AAAA,YACN;AAAA,UACJ;AAAA,QACJ;AAAA,MACJ,CAAC;AAGD,WAAK,IAAI,GAAG,SAAS,CAAC,QAAQ;AAC1B,oBAAY;AAAA,UACR;AAAA,UACA,IAAI,QAAQ;AAAA,QAChB;AAAA,MACJ,CAAC;AAED,WAAK,IAAI,GAAG,YAAY,CAAC,QAAQ;AAC7B,oBAAY;AAAA,UACR;AAAA,UACA,IAAI,QAAQ,SAAS;AAAA,QACzB;AAAA,MACJ,CAAC;AAED,WAAK,IAAI,MAAM,CAAC,KAAK,QAAQ;AACzB,oBAAY;AAAA,UACR,6BAAwB,IAAI,UAAU;AAAA,UACtC;AAAA,QACJ;AACA,YAAI;AAAA,UACA;AAAA,QACJ;AAAA,MACJ,CAAC;AAGD,YAAM,kBAAkB,OAAO,WAAmB;AAC9C,oBAAY;AAAA,UACR,yBAAe,MAAM;AAAA,QACzB;AACA,YAAI;AACA,gBAAM,KAAK,KAAK;AAChB,sBAAY,IAAI,2CAAoC;AAAA,QACxD,SAAS,OAAO;AACZ,sBAAY;AAAA,YACR;AAAA,YACA;AAAA,UACJ;AACA,gBAAM;AAAA,QACV;AAAA,MACJ;AAEA,cAAQ,KAAK,UAAU,MAAM,gBAAgB,QAAQ,CAAC;AACtD,cAAQ,KAAK,WAAW,MAAM,gBAAgB,SAAS,CAAC;AACxD,cAAQ,KAAK,UAAU,MAAM,gBAAgB,QAAQ,CAAC;AAAA,IAC1D,SAAS,OAAO;AACZ,kBAAY,MAAM,yCAAoC,KAAK;AAC3D,YAAM;AAAA,IACV;AAAA,EACJ;AAAA,EAEA,MAAa,OAAsB;AAC/B,gBAAY,IAAI,0BAA0B;AAC1C,UAAM,KAAK,IAAI,KAAK;AACpB,gBAAY,IAAI,sBAAsB;AAAA,EAC1C;AACJ;;;AE9GA,SAAS,SAAS;AAEX,IAAM,oBAAoB,EAAE,OAAO;AAAA,EACtC,oBAAoB,EAAE,OAAO,EAAE,IAAI,GAAG,gCAAgC;AAC1E,CAAC;AAID,eAAsB,uBAClB,SACuB;AACvB,MAAI;AACA,UAAM,SAAS;AAAA,MACX,oBACI,QAAQ,WAAW,oBAAoB,KACvC,QAAQ,IAAI;AAAA,IACpB;AAEA,WAAO,kBAAkB,MAAM,MAAM;AAAA,EACzC,SAAS,OAAO;AACZ,QAAI,iBAAiB,EAAE,UAAU;AAC7B,YAAM,gBAAgB,MAAM,OACvB,IAAI,CAAC,QAAQ,GAAG,IAAI,KAAK,KAAK,GAAG,CAAC,KAAK,IAAI,OAAO,EAAE,EACpD,KAAK,IAAI;AACd,YAAM,IAAI;AAAA,QACN;AAAA,EAA8C,aAAa;AAAA,MAC/D;AAAA,IACJ;AACA,UAAM;AAAA,EACV;AACJ;;;AH1BO,IAAM,0BAAkC;AAAA,EAC3C,OAAO,OAAO,YAA2B;AACrC,UAAM,uBAAuB,OAAO;AAEpC,UAAM,KAAK,IAAI;AAAA,MACX;AAAA,MACA,QAAQ,WAAW,oBAAoB;AAAA,IAC3C;AAEA,UAAM,GAAG,MAAM;AAEf,IAAAC,aAAY;AAAA,MACR,6DAAwD,QAAQ,UAAU,IAAI;AAAA,IAClF;AACA,WAAO;AAAA,EACX;AAAA,EACA,MAAM,OAAO,YAA2B;AACpC,YAAQ,KAAK,+CAA+C;AAAA,EAChE;AACJ;AAEA,IAAO,cAAQ;","names":["elizaLogger","content","memory","elizaLogger"]}