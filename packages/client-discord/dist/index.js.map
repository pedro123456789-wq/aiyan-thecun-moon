{"version":3,"sources":["../src/index.ts","../src/actions/chat_with_attachments.ts","../src/actions/download_media.ts","../src/actions/joinvoice.ts","../src/actions/leavevoice.ts","../src/actions/summarize_conversation.ts","../src/actions/transcribe_media.ts","../src/messages.ts","../src/attachments.ts","../src/providers/channelState.ts","../src/providers/voiceState.ts","../src/voice.ts","../src/enviroment.ts"],"sourcesContent":["import { embeddingZeroVector } from \"@ai16z/eliza\";\nimport { Character, Client as ElizaClient, IAgentRuntime } from \"@ai16z/eliza\";\nimport { stringToUuid } from \"@ai16z/eliza\";\nimport { elizaLogger } from \"@ai16z/eliza\";\nimport {\n    Client,\n    Events,\n    GatewayIntentBits,\n    Guild,\n    MessageReaction,\n    Partials,\n    User,\n} from \"discord.js\";\nimport { EventEmitter } from \"events\";\nimport chat_with_attachments from \"./actions/chat_with_attachments.ts\";\nimport download_media from \"./actions/download_media.ts\";\nimport joinvoice from \"./actions/joinvoice.ts\";\nimport leavevoice from \"./actions/leavevoice.ts\";\nimport summarize from \"./actions/summarize_conversation.ts\";\nimport transcribe_media from \"./actions/transcribe_media.ts\";\nimport { MessageManager } from \"./messages.ts\";\nimport channelStateProvider from \"./providers/channelState.ts\";\nimport voiceStateProvider from \"./providers/voiceState.ts\";\nimport { VoiceManager } from \"./voice.ts\";\nimport { validateDiscordConfig } from \"./enviroment.ts\";\n\nexport class DiscordClient extends EventEmitter {\n    apiToken: string;\n    client: Client;\n    runtime: IAgentRuntime;\n    character: Character;\n    private messageManager: MessageManager;\n    private voiceManager: VoiceManager;\n\n    constructor(runtime: IAgentRuntime) {\n        super();\n        this.apiToken = runtime.getSetting(\"DISCORD_API_TOKEN\") as string;\n        this.client = new Client({\n            intents: [\n                GatewayIntentBits.Guilds,\n                GatewayIntentBits.DirectMessages,\n                GatewayIntentBits.GuildVoiceStates,\n                GatewayIntentBits.MessageContent,\n                GatewayIntentBits.GuildMessages,\n                GatewayIntentBits.DirectMessageTyping,\n                GatewayIntentBits.GuildMessageTyping,\n                GatewayIntentBits.GuildMessageReactions,\n            ],\n            partials: [\n                Partials.Channel,\n                Partials.Message,\n                Partials.User,\n                Partials.Reaction,\n            ],\n        });\n\n        this.runtime = runtime;\n        this.voiceManager = new VoiceManager(this);\n        this.messageManager = new MessageManager(this, this.voiceManager);\n\n        this.client.once(Events.ClientReady, this.onClientReady.bind(this));\n        this.client.login(this.apiToken);\n\n        this.setupEventListeners();\n\n        this.runtime.registerAction(joinvoice);\n        this.runtime.registerAction(leavevoice);\n        this.runtime.registerAction(summarize);\n        this.runtime.registerAction(chat_with_attachments);\n        this.runtime.registerAction(transcribe_media);\n        this.runtime.registerAction(download_media);\n\n        this.runtime.providers.push(channelStateProvider);\n        this.runtime.providers.push(voiceStateProvider);\n    }\n\n    private setupEventListeners() {\n        // When joining to a new server\n        this.client.on(\"guildCreate\", this.handleGuildCreate.bind(this));\n\n        this.client.on(\n            Events.MessageReactionAdd,\n            this.handleReactionAdd.bind(this)\n        );\n        this.client.on(\n            Events.MessageReactionRemove,\n            this.handleReactionRemove.bind(this)\n        );\n\n        // Handle voice events with the voice manager\n        this.client.on(\n            \"voiceStateUpdate\",\n            this.voiceManager.handleVoiceStateUpdate.bind(this.voiceManager)\n        );\n        this.client.on(\n            \"userStream\",\n            this.voiceManager.handleUserStream.bind(this.voiceManager)\n        );\n\n        // Handle a new message with the message manager\n        this.client.on(\n            Events.MessageCreate,\n            this.messageManager.handleMessage.bind(this.messageManager)\n        );\n\n        // Handle a new interaction\n        this.client.on(\n            Events.InteractionCreate,\n            this.handleInteractionCreate.bind(this)\n        );\n    }\n\n    private async onClientReady(readyClient: { user: { tag: any; id: any } }) {\n        elizaLogger.success(`Logged in as ${readyClient.user?.tag}`);\n        elizaLogger.success(\"Use this URL to add the bot to your server:\");\n        elizaLogger.success(\n            `https://discord.com/api/oauth2/authorize?client_id=${readyClient.user?.id}&permissions=0&scope=bot%20applications.commands`\n        );\n        await this.onReady();\n    }\n\n    async handleReactionAdd(reaction: MessageReaction, user: User) {\n        elizaLogger.log(\"Reaction added\");\n        // if (user.bot) return;\n\n        let emoji = reaction.emoji.name;\n        if (!emoji && reaction.emoji.id) {\n            emoji = `<:${reaction.emoji.name}:${reaction.emoji.id}>`;\n        }\n\n        // Fetch the full message if it's a partial\n        if (reaction.partial) {\n            try {\n                await reaction.fetch();\n            } catch (error) {\n                console.error(\n                    \"Something went wrong when fetching the message:\",\n                    error\n                );\n                return;\n            }\n        }\n\n        const messageContent = reaction.message.content;\n        const truncatedContent =\n            messageContent.length > 100\n                ? messageContent.substring(0, 100) + \"...\"\n                : messageContent;\n\n        const reactionMessage = `*<${emoji}>: \"${truncatedContent}\"*`;\n\n        const roomId = stringToUuid(\n            reaction.message.channel.id + \"-\" + this.runtime.agentId\n        );\n        const userIdUUID = stringToUuid(user.id + \"-\" + this.runtime.agentId);\n\n        // Generate a unique UUID for the reaction\n        const reactionUUID = stringToUuid(\n            `${reaction.message.id}-${user.id}-${emoji}-${this.runtime.agentId}`\n        );\n\n        // ensure the user id and room id are valid\n        if (!userIdUUID || !roomId) {\n            console.error(\"Invalid user id or room id\");\n            return;\n        }\n        const userName = reaction.message.author.username;\n        const name = reaction.message.author.displayName;\n\n        await this.runtime.ensureConnection(\n            userIdUUID,\n            roomId,\n            userName,\n            name,\n            \"discord\"\n        );\n\n        // Save the reaction as a message\n        await this.runtime.messageManager.createMemory({\n            id: reactionUUID, // This is the ID of the reaction message\n            userId: userIdUUID,\n            agentId: this.runtime.agentId,\n            content: {\n                text: reactionMessage,\n                source: \"discord\",\n                inReplyTo: stringToUuid(\n                    reaction.message.id + \"-\" + this.runtime.agentId\n                ), // This is the ID of the original message\n            },\n            roomId,\n            createdAt: Date.now(),\n            embedding: embeddingZeroVector,\n        });\n    }\n\n    async handleReactionRemove(reaction: MessageReaction, user: User) {\n        elizaLogger.log(\"Reaction removed\");\n        // if (user.bot) return;\n\n        let emoji = reaction.emoji.name;\n        if (!emoji && reaction.emoji.id) {\n            emoji = `<:${reaction.emoji.name}:${reaction.emoji.id}>`;\n        }\n\n        // Fetch the full message if it's a partial\n        if (reaction.partial) {\n            try {\n                await reaction.fetch();\n            } catch (error) {\n                console.error(\n                    \"Something went wrong when fetching the message:\",\n                    error\n                );\n                return;\n            }\n        }\n\n        const messageContent = reaction.message.content;\n        const truncatedContent =\n            messageContent.length > 50\n                ? messageContent.substring(0, 50) + \"...\"\n                : messageContent;\n\n        const reactionMessage = `*Removed <${emoji} emoji> from: \"${truncatedContent}\"*`;\n\n        const roomId = stringToUuid(\n            reaction.message.channel.id + \"-\" + this.runtime.agentId\n        );\n        const userIdUUID = stringToUuid(user.id);\n\n        // Generate a unique UUID for the reaction removal\n        const reactionUUID = stringToUuid(\n            `${reaction.message.id}-${user.id}-${emoji}-removed-${this.runtime.agentId}`\n        );\n\n        const userName = reaction.message.author.username;\n        const name = reaction.message.author.displayName;\n\n        await this.runtime.ensureConnection(\n            userIdUUID,\n            roomId,\n            userName,\n            name,\n            \"discord\"\n        );\n\n        try {\n            // Save the reaction removal as a message\n            await this.runtime.messageManager.createMemory({\n                id: reactionUUID, // This is the ID of the reaction removal message\n                userId: userIdUUID,\n                agentId: this.runtime.agentId,\n                content: {\n                    text: reactionMessage,\n                    source: \"discord\",\n                    inReplyTo: stringToUuid(\n                        reaction.message.id + \"-\" + this.runtime.agentId\n                    ), // This is the ID of the original message\n                },\n                roomId,\n                createdAt: Date.now(),\n                embedding: embeddingZeroVector,\n            });\n        } catch (error) {\n            console.error(\"Error creating reaction removal message:\", error);\n        }\n    }\n\n    private handleGuildCreate(guild: Guild) {\n        console.log(`Joined guild ${guild.name}`);\n        this.voiceManager.scanGuild(guild);\n    }\n\n    private async handleInteractionCreate(interaction: any) {\n        if (!interaction.isCommand()) return;\n\n        switch (interaction.commandName) {\n            case \"joinchannel\":\n                await this.voiceManager.handleJoinChannelCommand(interaction);\n                break;\n            case \"leavechannel\":\n                await this.voiceManager.handleLeaveChannelCommand(interaction);\n                break;\n        }\n    }\n\n    private async onReady() {\n        const guilds = await this.client.guilds.fetch();\n        for (const [, guild] of guilds) {\n            const fullGuild = await guild.fetch();\n            this.voiceManager.scanGuild(fullGuild);\n        }\n    }\n}\n\nexport function startDiscord(runtime: IAgentRuntime) {\n    return new DiscordClient(runtime);\n}\n\nexport const DiscordClientInterface: ElizaClient = {\n    start: async (runtime: IAgentRuntime) => {\n        await validateDiscordConfig(runtime);\n\n        return new DiscordClient(runtime);\n    },\n    stop: async (runtime: IAgentRuntime) => {\n        console.warn(\"Discord client does not support stopping yet\");\n    },\n};\n","import { composeContext } from \"@ai16z/eliza\";\nimport { generateText, trimTokens } from \"@ai16z/eliza\";\nimport { models } from \"@ai16z/eliza\";\nimport { parseJSONObjectFromText } from \"@ai16z/eliza\";\nimport {\n    Action,\n    ActionExample,\n    Content,\n    HandlerCallback,\n    IAgentRuntime,\n    Memory,\n    ModelClass,\n    State,\n} from \"@ai16z/eliza\";\nexport const summarizationTemplate = `# Summarized so far (we are adding to this)\n{{currentSummary}}\n\n# Current attachments we are summarizing\n{{attachmentsWithText}}\n\nSummarization objective: {{objective}}\n\n# Instructions: Summarize the attachments. Return the summary. Do not acknowledge this request, just summarize and continue the existing summary if there is one. Capture any important details based on the objective. Only respond with the new summary text.`;\n\nexport const attachmentIdsTemplate = `# Messages we are summarizing \n{{recentMessages}}\n\n# Instructions: {{senderName}} is requesting a summary of specific attachments. Your goal is to determine their objective, along with the list of attachment IDs to summarize.\nThe \"objective\" is a detailed description of what the user wants to summarize based on the conversation.\nThe \"attachmentIds\" is an array of attachment IDs that the user wants to summarize. If not specified, default to including all attachments from the conversation.\n\nYour response must be formatted as a JSON block with this structure:\n\\`\\`\\`json\n{\n  \"objective\": \"<What the user wants to summarize>\",\n  \"attachmentIds\": [\"<Attachment ID 1>\", \"<Attachment ID 2>\", ...]\n}\n\\`\\`\\`\n`;\n\nconst getAttachmentIds = async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State\n): Promise<{ objective: string; attachmentIds: string[] } | null> => {\n    state = (await runtime.composeState(message)) as State;\n\n    const context = composeContext({\n        state,\n        template: attachmentIdsTemplate,\n    });\n\n    for (let i = 0; i < 5; i++) {\n        const response = await generateText({\n            runtime,\n            context,\n            modelClass: ModelClass.SMALL,\n        });\n        console.log(\"response\", response);\n        // try parsing to a json object\n        const parsedResponse = parseJSONObjectFromText(response) as {\n            objective: string;\n            attachmentIds: string[];\n        } | null;\n        // see if it contains objective and attachmentIds\n        if (parsedResponse?.objective && parsedResponse?.attachmentIds) {\n            return parsedResponse;\n        }\n    }\n    return null;\n};\n\nconst summarizeAction = {\n    name: \"CHAT_WITH_ATTACHMENTS\",\n    similes: [\n        \"CHAT_WITH_ATTACHMENT\",\n        \"SUMMARIZE_FILES\",\n        \"SUMMARIZE_FILE\",\n        \"SUMMARIZE_ATACHMENT\",\n        \"CHAT_WITH_PDF\",\n        \"ATTACHMENT_SUMMARY\",\n        \"RECAP_ATTACHMENTS\",\n        \"SUMMARIZE_FILE\",\n        \"SUMMARIZE_VIDEO\",\n        \"SUMMARIZE_AUDIO\",\n        \"SUMMARIZE_IMAGE\",\n        \"SUMMARIZE_DOCUMENT\",\n        \"SUMMARIZE_LINK\",\n        \"ATTACHMENT_SUMMARY\",\n        \"FILE_SUMMARY\",\n    ],\n    description:\n        \"Answer a user request informed by specific attachments based on their IDs. If a user asks to chat with a PDF, or wants more specific information about a link or video or anything else they've attached, this is the action to use.\",\n    validate: async (runtime: IAgentRuntime, message: Memory, state: State) => {\n        if (message.content.source !== \"discord\") {\n            return false;\n        }\n        // only show if one of the keywords are in the message\n        const keywords: string[] = [\n            \"attachment\",\n            \"summary\",\n            \"summarize\",\n            \"research\",\n            \"pdf\",\n            \"video\",\n            \"audio\",\n            \"image\",\n            \"document\",\n            \"link\",\n            \"file\",\n            \"attachment\",\n            \"summarize\",\n            \"code\",\n            \"report\",\n            \"write\",\n            \"details\",\n            \"information\",\n            \"talk\",\n            \"chat\",\n            \"read\",\n            \"listen\",\n            \"watch\",\n        ];\n        return keywords.some((keyword) =>\n            message.content.text.toLowerCase().includes(keyword.toLowerCase())\n        );\n    },\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        options: any,\n        callback: HandlerCallback\n    ) => {\n        state = (await runtime.composeState(message)) as State;\n\n        const callbackData: Content = {\n            text: \"\", // fill in later\n            action: \"CHAT_WITH_ATTACHMENTS_RESPONSE\",\n            source: message.content.source,\n            attachments: [],\n        };\n\n        // 1. extract attachment IDs from the message\n        const attachmentData = await getAttachmentIds(runtime, message, state);\n        if (!attachmentData) {\n            console.error(\"Couldn't get attachment IDs from message\");\n            return;\n        }\n\n        const { objective, attachmentIds } = attachmentData;\n\n        // This is pretty gross but it can catch cases where the returned generated UUID is stupidly wrong for some reason\n        const attachments = state.recentMessagesData\n            .filter(\n                (msg) =>\n                    msg.content.attachments &&\n                    msg.content.attachments.length > 0\n            )\n            .flatMap((msg) => msg.content.attachments)\n            // check by first 5 characters of uuid\n            .filter(\n                (attachment) =>\n                    attachmentIds\n                        .map((attch) => attch.toLowerCase().slice(0, 5))\n                        .includes(attachment.id.toLowerCase().slice(0, 5)) ||\n                    // or check the other way\n                    attachmentIds.some((id) => {\n                        const attachmentId = id.toLowerCase().slice(0, 5);\n                        return attachment.id\n                            .toLowerCase()\n                            .includes(attachmentId);\n                    })\n            );\n\n        const attachmentsWithText = attachments\n            .map((attachment) => `# ${attachment.title}\\n${attachment.text}`)\n            .join(\"\\n\\n\");\n\n        let currentSummary = \"\";\n\n        const model = models[runtime.character.modelProvider];\n        const chunkSize = model.settings.maxOutputTokens;\n\n        state.attachmentsWithText = attachmentsWithText;\n        state.objective = objective;\n\n        const context = composeContext({\n            state,\n            // make sure it fits, we can pad the tokens a bit\n            template: trimTokens(\n                summarizationTemplate,\n                chunkSize + 500,\n                \"gpt-4o-mini\" // TODO: make this dynamic and generic\n            ),\n        });\n\n        const summary = await generateText({\n            runtime,\n            context,\n            modelClass: ModelClass.SMALL,\n        });\n\n        currentSummary = currentSummary + \"\\n\" + summary;\n\n        if (!currentSummary) {\n            console.error(\"No summary found, that's not good!\");\n            return;\n        }\n\n        callbackData.text = currentSummary.trim();\n        if (\n            callbackData.text &&\n            (currentSummary.trim()?.split(\"\\n\").length < 4 ||\n                currentSummary.trim()?.split(\" \").length < 100)\n        ) {\n            callbackData.text = `Here is the summary:\n\\`\\`\\`md\n${currentSummary.trim()}\n\\`\\`\\`\n`;\n            await callback(callbackData);\n        } else if (currentSummary.trim()) {\n            const summaryFilename = `content/summary_${Date.now()}`;\n            await runtime.cacheManager.set(summaryFilename, currentSummary);\n            // save the summary to a file\n            await callback(\n                {\n                    ...callbackData,\n                    text: `I've attached the summary of the requested attachments as a text file.`,\n                },\n                [summaryFilename]\n            );\n        } else {\n            console.warn(\n                \"Empty response from chat with attachments action, skipping\"\n            );\n        }\n\n        return callbackData;\n    },\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Can you summarize the attachments b3e23, c4f67, and d5a89?\",\n                },\n            },\n            {\n                user: \"{{user2}}\",\n                content: {\n                    text: \"Sure thing! I'll pull up those specific attachments and provide a summary of their content.\",\n                    action: \"CHAT_WITH_ATTACHMENTS\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"I need a technical summary of the PDFs I sent earlier - a1b2c3.pdf, d4e5f6.pdf, and g7h8i9.pdf\",\n                },\n            },\n            {\n                user: \"{{user2}}\",\n                content: {\n                    text: \"I'll take a look at those specific PDF attachments and put together a technical summary for you. Give me a few minutes to review them.\",\n                    action: \"CHAT_WITH_ATTACHMENTS\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Can you watch this video for me and tell me which parts you think are most relevant to the report I'm writing? (the one I attached in my last message)\",\n                },\n            },\n            {\n                user: \"{{user2}}\",\n                content: {\n                    text: \"sure, no problem.\",\n                    action: \"CHAT_WITH_ATTACHMENTS\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"can you read my blog post and give me a detailed breakdown of the key points I made, and then suggest a handful of tweets to promote it?\",\n                },\n            },\n            {\n                user: \"{{user2}}\",\n                content: {\n                    text: \"great idea, give me a minute\",\n                    action: \"CHAT_WITH_ATTACHMENTS\",\n                },\n            },\n        ],\n    ] as ActionExample[][],\n} as Action;\n\nexport default summarizeAction;\n","import path from \"path\";\nimport { composeContext } from \"@ai16z/eliza\";\nimport { parseJSONObjectFromText } from \"@ai16z/eliza\";\nimport {\n    Action,\n    ActionExample,\n    Content,\n    HandlerCallback,\n    IAgentRuntime,\n    IVideoService,\n    Memory,\n    ModelClass,\n    Service,\n    ServiceType,\n    State,\n} from \"@ai16z/eliza\";\nimport { generateText } from \"@ai16z/eliza\";\n\nexport const mediaUrlTemplate = `# Messages we are searching for a media URL\n{{recentMessages}}\n\n# Instructions: {{senderName}} is requesting to download a specific media file (video or audio). Your goal is to determine the URL of the media they want to download.\nThe \"mediaUrl\" is the URL of the media file that the user wants downloaded. If not specified, return null.\n\nYour response must be formatted as a JSON block with this structure:\n\\`\\`\\`json\n{\n  \"mediaUrl\": \"<Media URL>\"\n}\n\\`\\`\\`\n`;\n\nconst getMediaUrl = async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State\n): Promise<string | null> => {\n    if (!state) {\n        state = (await runtime.composeState(message)) as State;\n    }\n\n    const context = composeContext({\n        state,\n        template: mediaUrlTemplate,\n    });\n\n    for (let i = 0; i < 5; i++) {\n        const response = await generateText({\n            runtime,\n            context,\n            modelClass: ModelClass.SMALL,\n        });\n\n        const parsedResponse = parseJSONObjectFromText(response) as {\n            mediaUrl: string;\n        } | null;\n\n        if (parsedResponse?.mediaUrl) {\n            return parsedResponse.mediaUrl;\n        }\n    }\n    return null;\n};\n\nexport default {\n    name: \"DOWNLOAD_MEDIA\",\n    similes: [\n        \"DOWNLOAD_VIDEO\",\n        \"DOWNLOAD_AUDIO\",\n        \"GET_MEDIA\",\n        \"DOWNLOAD_PODCAST\",\n        \"DOWNLOAD_YOUTUBE\",\n    ],\n    description:\n        \"Downloads a video or audio file from a URL and attaches it to the response message.\",\n    validate: async (runtime: IAgentRuntime, message: Memory, state: State) => {\n        if (message.content.source !== \"discord\") {\n            return false;\n        }\n    },\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        options: any,\n        callback: HandlerCallback\n    ) => {\n        const videoService = runtime\n            .getService<IVideoService>(ServiceType.VIDEO)\n            .getInstance();\n        if (!state) {\n            state = (await runtime.composeState(message)) as State;\n        }\n\n        const mediaUrl = await getMediaUrl(runtime, message, state);\n        if (!mediaUrl) {\n            console.error(\"Couldn't get media URL from messages\");\n            return;\n        }\n\n        const videoInfo = await videoService.fetchVideoInfo(mediaUrl);\n        const mediaPath = await videoService.downloadVideo(videoInfo);\n\n        const response: Content = {\n            text: `I downloaded the video \"${videoInfo.title}\" and attached it below.`,\n            action: \"DOWNLOAD_MEDIA_RESPONSE\",\n            source: message.content.source,\n            attachments: [],\n        };\n\n        const filename = path.basename(mediaPath);\n\n        const maxRetries = 3;\n        let retries = 0;\n\n        while (retries < maxRetries) {\n            try {\n                await callback(\n                    {\n                        ...response,\n                    },\n                    [\"content_cache/\" + filename]\n                );\n                break;\n            } catch (error) {\n                retries++;\n                console.error(\n                    `Error sending message (attempt ${retries}):`,\n                    error\n                );\n\n                if (retries === maxRetries) {\n                    console.error(\n                        \"Max retries reached. Failed to send message with attachment.\"\n                    );\n                    break;\n                }\n\n                // Wait for a short delay before retrying\n                await new Promise((resolve) => setTimeout(resolve, 2000));\n            }\n        }\n\n        return response;\n    },\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"https://www.youtube.com/watch?v=dQw4w9WgXcQ\",\n                },\n            },\n            {\n                user: \"{{user2}}\",\n                content: {\n                    text: \"Downloading the YouTube video now, one sec\",\n                    action: \"DOWNLOAD_MEDIA\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Can you grab this video for me? https://vimeo.com/123456789\",\n                },\n            },\n            {\n                user: \"{{user2}}\",\n                content: {\n                    text: \"Sure thing, I'll download that Vimeo video for you\",\n                    action: \"DOWNLOAD_MEDIA\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"I need this video downloaded: https://www.youtube.com/watch?v=abcdefg\",\n                },\n            },\n            {\n                user: \"{{user2}}\",\n                content: {\n                    text: \"No problem, I'm on it. I'll have that YouTube video downloaded in a jiffy\",\n                    action: \"DOWNLOAD_MEDIA\",\n                },\n            },\n        ],\n    ] as ActionExample[][],\n} as Action;\n","// @ts-nocheck\n// src/actions/joinVoice\nimport {\n    Action,\n    ActionExample,\n    composeContext,\n    IAgentRuntime,\n    Memory,\n    State,\n} from \"@ai16z/eliza\";\nimport {\n    Channel,\n    ChannelType,\n    Client,\n    Message as DiscordMessage,\n    Guild,\n    GuildMember,\n} from \"discord.js\";\n\nexport default {\n    name: \"JOIN_VOICE\",\n    similes: [\n        \"JOIN_VOICE\",\n        \"JOIN_VC\",\n        \"JOIN_VOICE_CHAT\",\n        \"JOIN_VOICE_CHANNEL\",\n        \"JOIN_MEETING\",\n        \"JOIN_CALL\",\n    ],\n    validate: async (\n        _runtime: IAgentRuntime,\n        message: Memory,\n        state: State\n    ) => {\n        if (message.content.source !== \"discord\") {\n            // not a discord message\n            return false;\n        }\n\n        if (!state.discordClient) {\n            return;\n        }\n\n        // did they say something about joining a voice channel? if not, don't validate\n        const keywords = [\n            \"join\",\n            \"come to\",\n            \"come on\",\n            \"enter\",\n            \"voice\",\n            \"chat\",\n            \"talk\",\n            \"call\",\n            \"hop on\",\n            \"get on\",\n            \"vc\",\n            \"meeting\",\n            \"discussion\",\n        ];\n        if (\n            !keywords.some((keyword) =>\n                message.content.text.toLowerCase().includes(keyword)\n            )\n        ) {\n            return false;\n        }\n\n        const client = state.discordClient as Client;\n\n        // Check if the client is connected to any voice channel\n        const isConnectedToVoice = client.voice.adapters.size === 0;\n\n        return isConnectedToVoice;\n    },\n    description: \"Join a voice channel to participate in voice chat.\",\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State\n    ): Promise<boolean> => {\n        if (!state) {\n            console.error(\"State is not available.\");\n        }\n\n        // We normalize data in from voice channels\n        const discordMessage = (state.discordChannel ||\n            state.discordMessage) as DiscordMessage;\n\n        if (!discordMessage.content) {\n            discordMessage.content = message.content.text;\n        }\n\n        const id = (discordMessage as DiscordMessage).guild?.id as string;\n        const client = state.discordClient as Client;\n        const voiceChannels = (\n            client.guilds.cache.get(id) as Guild\n        ).channels.cache.filter(\n            (channel: Channel) => channel.type === ChannelType.GuildVoice\n        );\n\n        const messageContent = discordMessage.content;\n\n        const targetChannel = voiceChannels.find((channel) => {\n            const name = (channel as { name: string }).name.toLowerCase();\n\n            // remove all non-alphanumeric characters (keep spaces between words)\n            const replacedName = name.replace(/[^a-z0-9 ]/g, \"\");\n\n            return (\n                name.includes(messageContent) ||\n                messageContent.includes(name) ||\n                replacedName.includes(messageContent) ||\n                messageContent.includes(replacedName)\n            );\n        });\n\n        if (!state.voiceManager) {\n            state.voiceManager = new VoiceManager({\n                client: state.discordClient,\n                runtime: runtime,\n            });\n        }\n\n        if (targetChannel) {\n            state.voiceManager.joinVoiceChannel({\n                channelId: targetChannel.id,\n                guildId: (discordMessage as DiscordMessage).guild?.id as string,\n                adapterCreator: (client.guilds.cache.get(id) as Guild)\n                    .voiceAdapterCreator,\n            });\n            return true;\n        } else {\n            const member = (discordMessage as DiscordMessage)\n                .member as GuildMember;\n            if (member?.voice?.channel) {\n                state.voiceManager.joinVoiceChannel({\n                    channelId: member.voice.channel.id,\n                    guildId: (discordMessage as DiscordMessage).guild\n                        ?.id as string,\n                    adapterCreator: (client.guilds.cache.get(id) as Guild)\n                        .voiceAdapterCreator,\n                });\n                return true;\n            }\n\n            const messageTemplate = `\nThe user has requested to join a voice channel.\nHere is the list of channels available in the server:\n{{voiceChannels}}\n\nHere is the user's request:\n{{userMessage}}\n\nPlease respond with the name of the voice channel which the bot should join. Try to infer what channel the user is talking about. If the user didn't specify a voice channel, respond with \"none\".\nYou should only respond with the name of the voice channel or none, no commentary or additional information should be included.\n`;\n\n            const guessState = {\n                userMessage: message.content.text,\n                voiceChannels: voiceChannels\n                    .map((channel) => (channel as { name: string }).name)\n                    .join(\"\\n\"),\n            };\n\n            const context = composeContext({\n                template: messageTemplate,\n                state: guessState as unknown as State,\n            });\n\n            const datestr = new Date().toUTCString().replace(/:/g, \"-\");\n\n            const responseContent = await generateText({\n                runtime,\n                context,\n                modelClass: ModelClass.SMALL,\n            });\n\n            runtime.databaseAdapter.log({\n                body: { message, context, response: responseContent },\n                userId: message.userId,\n                roomId: message.roomId,\n                type: \"joinvoice\",\n            });\n\n            if (responseContent && responseContent.trim().length > 0) {\n                // join the voice channel\n                const channelName = responseContent.toLowerCase();\n\n                const targetChannel = voiceChannels.find((channel) => {\n                    const name = (\n                        channel as { name: string }\n                    ).name.toLowerCase();\n\n                    // remove all non-alphanumeric characters (keep spaces between words)\n                    const replacedName = name.replace(/[^a-z0-9 ]/g, \"\");\n\n                    return (\n                        name.includes(channelName) ||\n                        channelName.includes(name) ||\n                        replacedName.includes(channelName) ||\n                        channelName.includes(replacedName)\n                    );\n                });\n\n                if (targetChannel) {\n                    state.voiceManager.joinVoiceChannel({\n                        channelId: targetChannel.id,\n                        guildId: (discordMessage as DiscordMessage).guild\n                            ?.id as string,\n                        adapterCreator: (client.guilds.cache.get(id) as Guild)\n                            .voiceAdapterCreator,\n                    });\n                    return true;\n                }\n            }\n\n            await (discordMessage as DiscordMessage).reply(\n                \"I couldn't figure out which channel you wanted me to join.\"\n            );\n            return false;\n        }\n    },\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Hey, let's jump into the 'General' voice and chat\",\n                },\n            },\n            {\n                user: \"{{user2}}\",\n                content: {\n                    text: \"Sounds good\",\n                    action: \"JOIN_VOICE\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"{{user2}}, can you join the vc, I want to discuss our strat\",\n                },\n            },\n            {\n                user: \"{{user2}}\",\n                content: {\n                    text: \"Sure I'll join right now\",\n                    action: \"JOIN_VOICE\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"hey {{user2}}, we're having a team meeting in the 'conference' voice channel, plz join us\",\n                },\n            },\n            {\n                user: \"{{user2}}\",\n                content: {\n                    text: \"OK see you there\",\n                    action: \"JOIN_VOICE\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"{{user2}}, let's have a quick voice chat in the 'Lounge' channel.\",\n                },\n            },\n            {\n                user: \"{{user2}}\",\n                content: {\n                    text: \"kk be there in a sec\",\n                    action: \"JOIN_VOICE\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Hey {{user2}}, can you join me in the 'Music' voice channel\",\n                },\n            },\n            {\n                user: \"{{user2}}\",\n                content: {\n                    text: \"Sure\",\n                    action: \"JOIN_VOICE\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"join voice chat with us {{user2}}\",\n                },\n            },\n            {\n                user: \"{{user2}}\",\n                content: {\n                    text: \"coming\",\n                    action: \"JOIN_VOICE\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"hop in vc {{user2}}\",\n                },\n            },\n            {\n                user: \"{{user2}}\",\n                content: {\n                    text: \"joining now\",\n                    action: \"JOIN_VOICE\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"get in vc with us {{user2}}\",\n                },\n            },\n            {\n                user: \"{{user2}}\",\n                content: {\n                    text: \"im in\",\n                    action: \"JOIN_VOICE\",\n                },\n            },\n        ],\n    ] as ActionExample[][],\n} as Action;\n","// src/actions/leaveVoice\nimport { getVoiceConnection } from \"@discordjs/voice\";\nimport {\n    Channel,\n    ChannelType,\n    Client,\n    Message as DiscordMessage,\n} from \"discord.js\";\nimport {\n    Action,\n    ActionExample,\n    IAgentRuntime,\n    Memory,\n    State,\n} from \"@ai16z/eliza\";\n\nexport default {\n    name: \"LEAVE_VOICE\",\n    similes: [\n        \"LEAVE_VOICE\",\n        \"LEAVE_VC\",\n        \"LEAVE_VOICE_CHAT\",\n        \"LEAVE_VOICE_CHANNEL\",\n        \"LEAVE_MEETING\",\n        \"LEAVE_CALL\",\n    ],\n    validate: async (runtime: IAgentRuntime, message: Memory, state: State) => {\n        if (message.content.source !== \"discord\") {\n            // not a discord message\n            return false;\n        }\n\n        if (!state.discordClient) {\n            return false;\n        }\n\n        const keywords = [\n            \"leave\",\n            \"exit\",\n            \"stop\",\n            \"quit\",\n            \"get off\",\n            \"get out\",\n            \"bye\",\n            \"cya\",\n            \"see you\",\n            \"hop off\",\n            \"get off\",\n            \"voice\",\n            \"vc\",\n            \"chat\",\n            \"call\",\n            \"meeting\",\n            \"discussion\",\n        ];\n        if (\n            !keywords.some((keyword) =>\n                message.content.text.toLowerCase().includes(keyword)\n            )\n        ) {\n            return false;\n        }\n\n        const client = state.discordClient as Client;\n\n        // Check if the client is connected to any voice channel\n        const isConnectedToVoice = client.voice.adapters.size > 0;\n\n        return isConnectedToVoice;\n    },\n    description: \"Leave the current voice channel.\",\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State\n    ): Promise<boolean> => {\n        if (!state.discordClient) {\n            return;\n        }\n\n        const discordMessage = (state.discordMessage ||\n            state.discordChannel) as DiscordMessage;\n\n        if (!discordMessage) {\n            throw new Error(\"Discord message is not available in the state.\");\n        }\n        const voiceChannels = (state.discordClient as Client)?.guilds.cache\n            .get((discordMessage as DiscordMessage).guild?.id as string)\n            ?.channels.cache.filter(\n                (channel: Channel) => channel.type === ChannelType.GuildVoice\n            );\n\n        voiceChannels?.forEach((channel: Channel) => {\n            const connection = getVoiceConnection(\n                (discordMessage as DiscordMessage).guild?.id as string\n            );\n            if (connection) {\n                connection.destroy();\n            }\n        });\n        return true;\n    },\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Hey {{user2}} please leave the voice channel\",\n                },\n            },\n            {\n                user: \"{{user2}}\",\n                content: {\n                    text: \"Sure\",\n                    action: \"LEAVE_VOICE\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"I have to go now but thanks for the chat\",\n                },\n            },\n            {\n                user: \"{{user2}}\",\n                content: {\n                    text: \"You too, talk to you later\",\n                    action: \"LEAVE_VOICE\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Great call everyone, hopping off now\",\n                    action: \"LEAVE_VOICE\",\n                },\n            },\n            {\n                user: \"{{user2}}\",\n                content: {\n                    text: \"Agreed, I'll hop off too\",\n                    action: \"LEAVE_VOICE\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Hey {{user2}} I need you to step away from the voice chat for a bit\",\n                },\n            },\n            {\n                user: \"{{user2}}\",\n                content: {\n                    text: \"No worries, I'll leave the voice channel\",\n                    action: \"LEAVE_VOICE\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"{{user2}}, I think we covered everything, you can leave the voice chat now\",\n                },\n            },\n            {\n                user: \"{{user2}}\",\n                content: {\n                    text: \"Sounds good, see you both later\",\n                    action: \"LEAVE_VOICE\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"leave voice {{user2}}\",\n                },\n            },\n            {\n                user: \"{{user2}}\",\n                content: {\n                    text: \"ok leaving\",\n                    action: \"LEAVE_VOICE\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"plz leave the voice chat {{user2}}\",\n                },\n            },\n            {\n                user: \"{{user2}}\",\n                content: {\n                    text: \"aight im out\",\n                    action: \"LEAVE_VOICE\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"yo {{user2}} gtfo the vc\",\n                },\n            },\n            {\n                user: \"{{user2}}\",\n                content: {\n                    text: \"sorry, talk to you later\",\n                    action: \"LEAVE_VOICE\",\n                },\n            },\n        ],\n    ] as ActionExample[][],\n} as Action;\n","import { composeContext } from \"@ai16z/eliza\";\nimport { generateText, splitChunks, trimTokens } from \"@ai16z/eliza\";\nimport { getActorDetails } from \"@ai16z/eliza\";\nimport { models } from \"@ai16z/eliza\";\nimport { parseJSONObjectFromText } from \"@ai16z/eliza\";\nimport {\n    Action,\n    ActionExample,\n    Content,\n    HandlerCallback,\n    IAgentRuntime,\n    Media,\n    Memory,\n    ModelClass,\n    State,\n} from \"@ai16z/eliza\";\nexport const summarizationTemplate = `# Summarized so far (we are adding to this)\n{{currentSummary}}\n\n# Current conversation chunk we are summarizing (includes attachments)\n{{memoriesWithAttachments}}\n\nSummarization objective: {{objective}}\n\n# Instructions: Summarize the conversation so far. Return the summary. Do not acknowledge this request, just summarize and continue the existing summary if there is one. Capture any important details to the objective. Only respond with the new summary text.\nYour response should be extremely detailed and include any and all relevant information.`;\n\nexport const dateRangeTemplate = `# Messages we are summarizing (the conversation is continued after this)\n{{recentMessages}}\n\n# Instructions: {{senderName}} is requesting a summary of the conversation. Your goal is to determine their objective, along with the range of dates that their request covers.\nThe \"objective\" is a detailed description of what the user wants to summarize based on the conversation. If they just ask for a general summary, you can either base it off the converation if the summary range is very recent, or set the object to be general, like \"a detailed summary of the conversation between all users\".\nThe \"start\" and \"end\" are the range of dates that the user wants to summarize, relative to the current time. The start and end should be relative to the current time, and measured in seconds, minutes, hours and days. The format is \"2 days ago\" or \"3 hours ago\" or \"4 minutes ago\" or \"5 seconds ago\", i.e. \"<integer> <unit> ago\".\nIf you aren't sure, you can use a default range of \"0 minutes ago\" to \"2 hours ago\" or more. Better to err on the side of including too much than too little.\n\nYour response must be formatted as a JSON block with this structure:\n\\`\\`\\`json\n{\n  \"objective\": \"<What the user wants to summarize>\",\n  \"start\": \"0 minutes ago\",\n  \"end\": \"2 hours ago\"\n}\n\\`\\`\\`\n`;\n\nconst getDateRange = async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State\n) => {\n    state = (await runtime.composeState(message)) as State;\n\n    const context = composeContext({\n        state,\n        template: dateRangeTemplate,\n    });\n\n    for (let i = 0; i < 5; i++) {\n        const response = await generateText({\n            runtime,\n            context,\n            modelClass: ModelClass.SMALL,\n        });\n        console.log(\"response\", response);\n        // try parsing to a json object\n        const parsedResponse = parseJSONObjectFromText(response) as {\n            objective: string;\n            start: string | number;\n            end: string | number;\n        } | null;\n        // see if it contains objective, start and end\n        if (parsedResponse) {\n            if (\n                parsedResponse.objective &&\n                parsedResponse.start &&\n                parsedResponse.end\n            ) {\n                // TODO: parse start and end into timestamps\n                const startIntegerString = (\n                    parsedResponse.start as string\n                ).match(/\\d+/)?.[0];\n                const endIntegerString = (parsedResponse.end as string).match(\n                    /\\d+/\n                )?.[0];\n\n                // parse multiplier\n                const multipliers = {\n                    second: 1 * 1000,\n                    minute: 60 * 1000,\n                    hour: 3600 * 1000,\n                    day: 86400 * 1000,\n                };\n\n                const startMultiplier = (parsedResponse.start as string).match(\n                    /second|minute|hour|day/\n                )?.[0];\n                const endMultiplier = (parsedResponse.end as string).match(\n                    /second|minute|hour|day/\n                )?.[0];\n\n                const startInteger = startIntegerString\n                    ? parseInt(startIntegerString)\n                    : 0;\n                const endInteger = endIntegerString\n                    ? parseInt(endIntegerString)\n                    : 0;\n\n                // multiply by multiplier\n                const startTime =\n                    startInteger *\n                    multipliers[startMultiplier as keyof typeof multipliers];\n\n                console.log(\"startTime\", startTime);\n\n                const endTime =\n                    endInteger *\n                    multipliers[endMultiplier as keyof typeof multipliers];\n\n                console.log(\"endTime\", endTime);\n\n                // get the current time and subtract the start and end times\n                parsedResponse.start = Date.now() - startTime;\n                parsedResponse.end = Date.now() - endTime;\n\n                return parsedResponse;\n            }\n        }\n    }\n};\n\nconst summarizeAction = {\n    name: \"SUMMARIZE_CONVERSATION\",\n    similes: [\n        \"RECAP\",\n        \"RECAP_CONVERSATION\",\n        \"SUMMARIZE_CHAT\",\n        \"SUMMARIZATION\",\n        \"CHAT_SUMMARY\",\n        \"CONVERSATION_SUMMARY\",\n    ],\n    description: \"Summarizes the conversation and attachments.\",\n    validate: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        _state: State\n    ) => {\n        if (message.content.source !== \"discord\") {\n            return false;\n        }\n        // only show if one of the keywords are in the message\n        const keywords: string[] = [\n            \"summarize\",\n            \"summarization\",\n            \"summary\",\n            \"recap\",\n            \"report\",\n            \"overview\",\n            \"review\",\n            \"rundown\",\n            \"wrap-up\",\n            \"brief\",\n            \"debrief\",\n            \"abstract\",\n            \"synopsis\",\n            \"outline\",\n            \"digest\",\n            \"abridgment\",\n            \"condensation\",\n            \"encapsulation\",\n            \"essence\",\n            \"gist\",\n            \"main points\",\n            \"key points\",\n            \"key takeaways\",\n            \"bulletpoint\",\n            \"highlights\",\n            \"tldr\",\n            \"tl;dr\",\n            \"in a nutshell\",\n            \"bottom line\",\n            \"long story short\",\n            \"sum up\",\n            \"sum it up\",\n            \"short version\",\n            \"bring me up to speed\",\n            \"catch me up\",\n        ];\n        return keywords.some((keyword) =>\n            message.content.text.toLowerCase().includes(keyword.toLowerCase())\n        );\n    },\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        options: any,\n        callback: HandlerCallback\n    ) => {\n        state = (await runtime.composeState(message)) as State;\n\n        const callbackData: Content = {\n            text: \"\", // fill in later\n            action: \"SUMMARIZATION_RESPONSE\",\n            source: message.content.source,\n            attachments: [],\n        };\n        const { roomId } = message;\n\n        // 1. extract date range from the message\n        const dateRange = await getDateRange(runtime, message, state);\n        if (!dateRange) {\n            console.error(\"Couldn't get date range from message\");\n            return;\n        }\n\n        console.log(\"dateRange\", dateRange);\n\n        const { objective, start, end } = dateRange;\n\n        // 2. get these memories from the database\n        const memories = await runtime.messageManager.getMemories({\n            roomId,\n            agentId: runtime.agentId,\n            // subtract start from current time\n            start: parseInt(start as string),\n            end: parseInt(end as string),\n            count: 10000,\n            unique: false,\n        });\n\n        const actors = await getActorDetails({\n            runtime: runtime as IAgentRuntime,\n            roomId,\n        });\n\n        const actorMap = new Map(actors.map((actor) => [actor.id, actor]));\n\n        const formattedMemories = memories\n            .map((memory) => {\n                const attachments = memory.content.attachments\n                    ?.map((attachment: Media) => {\n                        return `---\\nAttachment: ${attachment.id}\\n${attachment.description}\\n${attachment.text}\\n---`;\n                    })\n                    .join(\"\\n\");\n                return `${actorMap.get(memory.userId)?.name ?? \"Unknown User\"} (${actorMap.get(memory.userId)?.username ?? \"\"}): ${memory.content.text}\\n${attachments}`;\n            })\n            .join(\"\\n\");\n\n        let currentSummary = \"\";\n\n        const model = models[runtime.character.settings.model];\n        const chunkSize = model.settings.maxContextLength - 1000;\n\n        const chunks = await splitChunks(formattedMemories, chunkSize, 0);\n\n        const datestr = new Date().toUTCString().replace(/:/g, \"-\");\n\n        state.memoriesWithAttachments = formattedMemories;\n        state.objective = objective;\n\n        for (let i = 0; i < chunks.length; i++) {\n            const chunk = chunks[i];\n            state.currentSummary = currentSummary;\n            state.currentChunk = chunk;\n            const context = composeContext({\n                state,\n                // make sure it fits, we can pad the tokens a bit\n                template: trimTokens(\n                    summarizationTemplate,\n                    chunkSize + 500,\n                    \"gpt-4o-mini\"\n                ),\n            });\n\n            const summary = await generateText({\n                runtime,\n                context,\n                modelClass: ModelClass.SMALL,\n            });\n\n            currentSummary = currentSummary + \"\\n\" + summary;\n        }\n\n        if (!currentSummary) {\n            console.error(\"No summary found, that's not good!\");\n            return;\n        }\n\n        callbackData.text = currentSummary.trim();\n        if (\n            callbackData.text &&\n            (currentSummary.trim()?.split(\"\\n\").length < 4 ||\n                currentSummary.trim()?.split(\" \").length < 100)\n        ) {\n            callbackData.text = `Here is the summary:\n\\`\\`\\`md\n${currentSummary.trim()}\n\\`\\`\\`\n`;\n            await callback(callbackData);\n        } else if (currentSummary.trim()) {\n            const summaryFilename = `content/conversation_summary_${Date.now()}`;\n            await runtime.cacheManager.set(summaryFilename, currentSummary);\n            // save the summary to a file\n            await callback(\n                {\n                    ...callbackData,\n                    text: `I've attached the summary of the conversation from \\`${new Date(parseInt(start as string)).toString()}\\` to \\`${new Date(parseInt(end as string)).toString()}\\` as a text file.`,\n                },\n                [summaryFilename]\n            );\n        } else {\n            console.warn(\n                \"Empty response from summarize conversation action, skipping\"\n            );\n        }\n\n        return callbackData;\n    },\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"```js\\nconst x = 10\\n```\",\n                },\n            },\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"can you give me a detailed report on what we're talking about?\",\n                },\n            },\n            {\n                user: \"{{user2}}\",\n                content: {\n                    text: \"sure, no problem, give me a minute to get that together for you\",\n                    action: \"SUMMARIZE\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"please summarize the conversation we just had and include this blogpost i'm linking (Attachment: b3e12)\",\n                },\n            },\n            {\n                user: \"{{user2}}\",\n                content: {\n                    text: \"sure, give me a sec\",\n                    action: \"SUMMARIZE\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Can you summarize what moon and avf are talking about?\",\n                },\n            },\n            {\n                user: \"{{user2}}\",\n                content: {\n                    text: \"Yeah, just hold on a second while I get that together for you...\",\n                    action: \"SUMMARIZE\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"i need to write a blog post about farming, can you summarize the discussion from a few hours ago?\",\n                },\n            },\n            {\n                user: \"{{user2}}\",\n                content: {\n                    text: \"no probblem, give me a few minutes to read through everything\",\n                    action: \"SUMMARIZE\",\n                },\n            },\n        ],\n    ] as ActionExample[][],\n} as Action;\n\nexport default summarizeAction;\n","import { composeContext } from \"@ai16z/eliza\";\nimport { generateText } from \"@ai16z/eliza\";\nimport { parseJSONObjectFromText } from \"@ai16z/eliza\";\nimport {\n    Action,\n    ActionExample,\n    Content,\n    HandlerCallback,\n    IAgentRuntime,\n    Memory,\n    ModelClass,\n    State,\n} from \"@ai16z/eliza\";\n\nexport const transcriptionTemplate = `# Transcription of media file\n{{mediaTranscript}}\n\n# Instructions: Return only the full transcript of the media file without any additional context or commentary.`;\n\nexport const mediaAttachmentIdTemplate = `# Messages we are transcribing\n{{recentMessages}}\n\n# Instructions: {{senderName}} is requesting a transcription of a specific media file (audio or video). Your goal is to determine the ID of the attachment they want transcribed.\nThe \"attachmentId\" is the ID of the media file attachment that the user wants transcribed. If not specified, return null.\n\nYour response must be formatted as a JSON block with this structure:\n\\`\\`\\`json\n{\n  \"attachmentId\": \"<Attachment ID>\"\n}\n\\`\\`\\`\n`;\n\nconst getMediaAttachmentId = async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State\n): Promise<string | null> => {\n    state = (await runtime.composeState(message)) as State;\n\n    const context = composeContext({\n        state,\n        template: mediaAttachmentIdTemplate,\n    });\n\n    for (let i = 0; i < 5; i++) {\n        const response = await generateText({\n            runtime,\n            context,\n            modelClass: ModelClass.SMALL,\n        });\n        console.log(\"response\", response);\n\n        const parsedResponse = parseJSONObjectFromText(response) as {\n            attachmentId: string;\n        } | null;\n\n        if (parsedResponse?.attachmentId) {\n            return parsedResponse.attachmentId;\n        }\n    }\n    return null;\n};\n\nconst transcribeMediaAction = {\n    name: \"TRANSCRIBE_MEDIA\",\n    similes: [\n        \"TRANSCRIBE_AUDIO\",\n        \"TRANSCRIBE_VIDEO\",\n        \"MEDIA_TRANSCRIPT\",\n        \"VIDEO_TRANSCRIPT\",\n        \"AUDIO_TRANSCRIPT\",\n    ],\n    description:\n        \"Transcribe the full text of an audio or video file that the user has attached.\",\n    validate: async (runtime: IAgentRuntime, message: Memory, state: State) => {\n        if (message.content.source !== \"discord\") {\n            return false;\n        }\n\n        const keywords: string[] = [\n            \"transcribe\",\n            \"transcript\",\n            \"audio\",\n            \"video\",\n            \"media\",\n            \"youtube\",\n            \"meeting\",\n            \"recording\",\n            \"podcast\",\n            \"call\",\n            \"conference\",\n            \"interview\",\n            \"speech\",\n            \"lecture\",\n            \"presentation\",\n        ];\n        return keywords.some((keyword) =>\n            message.content.text.toLowerCase().includes(keyword.toLowerCase())\n        );\n    },\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        options: any,\n        callback: HandlerCallback\n    ) => {\n        state = (await runtime.composeState(message)) as State;\n\n        const callbackData: Content = {\n            text: \"\", // fill in later\n            action: \"TRANSCRIBE_MEDIA_RESPONSE\",\n            source: message.content.source,\n            attachments: [],\n        };\n\n        const attachmentId = await getMediaAttachmentId(\n            runtime,\n            message,\n            state\n        );\n        if (!attachmentId) {\n            console.error(\"Couldn't get media attachment ID from message\");\n            return;\n        }\n\n        const attachment = state.recentMessagesData\n            .filter(\n                (msg) =>\n                    msg.content.attachments &&\n                    msg.content.attachments.length > 0\n            )\n            .flatMap((msg) => msg.content.attachments)\n            .find(\n                (attachment) =>\n                    attachment.id.toLowerCase() === attachmentId.toLowerCase()\n            );\n\n        if (!attachment) {\n            console.error(`Couldn't find attachment with ID ${attachmentId}`);\n            return;\n        }\n\n        const mediaTranscript = attachment.text;\n\n        callbackData.text = mediaTranscript.trim();\n\n        // if callbackData.text is < 4 lines or < 100 words, then we we callback with normal message wrapped in markdown block\n        if (\n            callbackData.text &&\n            (callbackData.text?.split(\"\\n\").length < 4 ||\n                callbackData.text?.split(\" \").length < 100)\n        ) {\n            callbackData.text = `Here is the transcript:\n\\`\\`\\`md\n${mediaTranscript.trim()}\n\\`\\`\\`\n`;\n            await callback(callbackData);\n        }\n        // if text is big, let's send as an attachment\n        else if (callbackData.text) {\n            const transcriptFilename = `content/transcript_${Date.now()}`;\n\n            // save the transcript to a file\n            await runtime.cacheManager.set(\n                transcriptFilename,\n                callbackData.text\n            );\n\n            await callback(\n                {\n                    ...callbackData,\n                    text: `I've attached the transcript as a text file.`,\n                },\n                [transcriptFilename]\n            );\n        } else {\n            console.warn(\n                \"Empty response from transcribe media action, skipping\"\n            );\n        }\n\n        return callbackData;\n    },\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Please transcribe the audio file I just sent.\",\n                },\n            },\n            {\n                user: \"{{user2}}\",\n                content: {\n                    text: \"Sure, I'll transcribe the full audio for you.\",\n                    action: \"TRANSCRIBE_MEDIA\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Can I get a transcript of that video recording?\",\n                },\n            },\n            {\n                user: \"{{user2}}\",\n                content: {\n                    text: \"Absolutely, give me a moment to generate the full transcript of the video.\",\n                    action: \"TRANSCRIBE_MEDIA\",\n                },\n            },\n        ],\n    ] as ActionExample[][],\n} as Action;\n\nexport default transcribeMediaAction;\n","import { composeContext } from \"@ai16z/eliza\";\nimport { generateMessageResponse, generateShouldRespond } from \"@ai16z/eliza\";\nimport { embeddingZeroVector } from \"@ai16z/eliza\";\nimport { messageCompletionFooter, shouldRespondFooter } from \"@ai16z/eliza\";\nimport {\n    Content,\n    HandlerCallback,\n    IAgentRuntime,\n    IBrowserService,\n    ISpeechService,\n    IVideoService,\n    Media,\n    Memory,\n    ModelClass,\n    ServiceType,\n    State,\n    UUID,\n} from \"@ai16z/eliza\";\nimport { stringToUuid } from \"@ai16z/eliza\";\nimport { generateText, trimTokens } from \"@ai16z/eliza\";\nimport { parseJSONObjectFromText } from \"@ai16z/eliza\";\nimport {\n    ChannelType,\n    Client,\n    Message as DiscordMessage,\n    PermissionsBitField,\n    TextChannel,\n    ThreadChannel,\n} from \"discord.js\";\nimport { elizaLogger } from \"@ai16z/eliza\";\nimport { AttachmentManager } from \"./attachments.ts\";\nimport { VoiceManager } from \"./voice.ts\";\n\nconst MAX_MESSAGE_LENGTH = 1900;\nasync function generateSummary(\n    runtime: IAgentRuntime,\n    text: string\n): Promise<{ title: string; description: string }> {\n    // make sure text is under 128k characters\n    text = trimTokens(text, 100000, \"gpt-4o-mini\"); // TODO: clean this up\n\n    const prompt = `Please generate a concise summary for the following text:\n  \n  Text: \"\"\"\n  ${text}\n  \"\"\"\n  \n  Respond with a JSON object in the following format:\n  \\`\\`\\`json\n  {\n    \"title\": \"Generated Title\",\n    \"summary\": \"Generated summary and/or description of the text\"\n  }\n  \\`\\`\\``;\n\n    const response = await generateText({\n        runtime,\n        context: prompt,\n        modelClass: ModelClass.SMALL,\n    });\n\n    const parsedResponse = parseJSONObjectFromText(response);\n\n    if (parsedResponse) {\n        return {\n            title: parsedResponse.title,\n            description: parsedResponse.summary,\n        };\n    }\n\n    return {\n        title: \"\",\n        description: \"\",\n    };\n}\n\nexport type InterestChannels = {\n    [key: string]: {\n        lastMessageSent: number;\n        messages: { userId: UUID; userName: string; content: Content }[];\n    };\n};\n\nconst discordShouldRespondTemplate =\n    `# About {{agentName}}:\n{{bio}}\n\n# RESPONSE EXAMPLES\n{{user1}}: I just saw a really great movie\n{{user2}}: Oh? Which movie?\nResult: [IGNORE]\n\n{{agentName}}: Oh, this is my favorite scene\n{{user1}}: sick\n{{user2}}: wait, why is it your favorite scene\nResult: [RESPOND]\n\n{{user1}}: stfu bot\nResult: [STOP]\n\n{{user1}}: Hey {{agent}}, can you help me with something\nResult: [RESPOND]\n\n{{user1}}: {{agentName}} stfu plz\nResult: [STOP]\n\n{{user1}}: i need help\n{{agentName}}: how can I help you?\n{{user1}}: no. i need help from someone else\nResult: [IGNORE]\n\n{{user1}}: Hey {{agent}}, can I ask you a question\n{{agentName}}: Sure, what is it\n{{user1}}: can you ask claude to create a basic react module that demonstrates a counter\nResult: [RESPOND]\n\n{{user1}}: {{agentName}} can you tell me a story\n{{agentName}}: uhhh...\n{{user1}}: please do it\n{{agentName}}: okay\n{{agentName}}: once upon a time, in a quaint little village, there was a curious girl named elara\n{{user1}}: I'm loving it, keep going\nResult: [RESPOND]\n\n{{user1}}: {{agentName}} stop responding plz\nResult: [STOP]\n\n{{user1}}: okay, i want to test something. {{agentName}}, can you say marco?\n{{agentName}}: marco\n{{user1}}: great. okay, now do it again\nResult: [RESPOND]\n\nResponse options are [RESPOND], [IGNORE] and [STOP].\n\n{{agentName}} is in a room with other users and should only respond when they are being addressed, and should not respond if they are continuing a conversation that is very long.\n\nRespond with [RESPOND] to messages that are directed at {{agentName}}, or participate in conversations that are interesting or relevant to their background.\nIf a message is not interesting, relevant, or does not directly address {{agentName}}, respond with [IGNORE]\n\nAlso, respond with [IGNORE] to messages that are very short or do not contain much information.\n\nIf a user asks {{agentName}} to be quiet, respond with [STOP]\nIf {{agentName}} concludes a conversation and isn't part of the conversation anymore, respond with [STOP]\n\nIMPORTANT: {{agentName}} is particularly sensitive about being annoying, so if there is any doubt, it is better to respond with [IGNORE].\nIf {{agentName}} is conversing with a user and they have not asked to stop, it is better to respond with [RESPOND].\n\nThe goal is to decide whether {{agentName}} should respond to the last message.\n\n{{recentMessages}}\n\n# INSTRUCTIONS: Choose the option that best describes {{agentName}}'s response to the last message. Ignore messages if they are addressed to someone else.\n` + shouldRespondFooter;\n\nexport const discordMessageHandlerTemplate =\n    // {{goals}}\n    `# Action Examples\n{{actionExamples}}\n(Action examples are for reference only. Do not use the information from them in your response.)\n\n# Knowledge\n{{knowledge}}\n\n# Task: Generate dialog and actions for the character {{agentName}}.\nAbout {{agentName}}:\n{{bio}}\n{{lore}}\n\nExamples of {{agentName}}'s dialog and actions:\n{{characterMessageExamples}}\n\n{{providers}}\n\n{{attachments}}\n\n{{actions}}\n\n# Capabilities\nNote that {{agentName}} is capable of reading/seeing/hearing various forms of media, including images, videos, audio, plaintext and PDFs. Recent attachments have been included above under the \"Attachments\" section.\n\n{{messageDirections}}\n\n{{recentMessages}}\n\n# Instructions: Write the next message for {{agentName}}. Include an action, if appropriate. {{actionNames}}\n` + messageCompletionFooter;\n\nexport async function sendMessageInChunks(\n    channel: TextChannel,\n    content: string,\n    inReplyTo: string,\n    files: any[]\n): Promise<DiscordMessage[]> {\n    const sentMessages: DiscordMessage[] = [];\n    const messages = splitMessage(content);\n    try {\n        for (let i = 0; i < messages.length; i++) {\n            const message = messages[i];\n            if (\n                message.trim().length > 0 ||\n                (i === messages.length - 1 && files && files.length > 0)\n            ) {\n                const options: any = {\n                    content: message.trim(),\n                };\n\n                // if (i === 0 && inReplyTo) {\n                //   // Reply to the specified message for the first chunk\n                //   options.reply = {\n                //     messageReference: inReplyTo,\n                //   };\n                // }\n\n                if (i === messages.length - 1 && files && files.length > 0) {\n                    // Attach files to the last message chunk\n                    options.files = files;\n                }\n\n                const m = await channel.send(options);\n                sentMessages.push(m);\n            }\n        }\n    } catch (error) {\n        elizaLogger.error(\"Error sending message:\", error);\n    }\n\n    return sentMessages;\n}\n\nfunction splitMessage(content: string): string[] {\n    const messages: string[] = [];\n    let currentMessage = \"\";\n\n    const rawLines = content?.split(\"\\n\") || [];\n    // split all lines into MAX_MESSAGE_LENGTH chunks so any long lines are split\n    const lines = rawLines\n        .map((line) => {\n            const chunks = [];\n            while (line.length > MAX_MESSAGE_LENGTH) {\n                chunks.push(line.slice(0, MAX_MESSAGE_LENGTH));\n                line = line.slice(MAX_MESSAGE_LENGTH);\n            }\n            chunks.push(line);\n            return chunks;\n        })\n        .flat();\n\n    for (const line of lines) {\n        if (currentMessage.length + line.length + 1 > MAX_MESSAGE_LENGTH) {\n            messages.push(currentMessage.trim());\n            currentMessage = \"\";\n        }\n        currentMessage += line + \"\\n\";\n    }\n\n    if (currentMessage.trim().length > 0) {\n        messages.push(currentMessage.trim());\n    }\n\n    return messages;\n}\n\nfunction canSendMessage(channel) {\n    // if it is a DM channel, we can always send messages\n    if (channel.type === ChannelType.DM) {\n        return {\n            canSend: true,\n            reason: null,\n        };\n    }\n    const botMember = channel.guild?.members.cache.get(channel.client.user.id);\n\n    if (!botMember) {\n        return {\n            canSend: false,\n            reason: \"Not a guild channel or bot member not found\",\n        };\n    }\n\n    // Required permissions for sending messages\n    const requiredPermissions = [\n        PermissionsBitField.Flags.ViewChannel,\n        PermissionsBitField.Flags.SendMessages,\n        PermissionsBitField.Flags.ReadMessageHistory,\n    ];\n\n    // Add thread-specific permission if it's a thread\n    if (channel instanceof ThreadChannel) {\n        requiredPermissions.push(\n            PermissionsBitField.Flags.SendMessagesInThreads\n        );\n    }\n\n    // Check permissions\n    const permissions = channel.permissionsFor(botMember);\n\n    if (!permissions) {\n        return {\n            canSend: false,\n            reason: \"Could not retrieve permissions\",\n        };\n    }\n\n    // Check each required permission\n    const missingPermissions = requiredPermissions.filter(\n        (perm) => !permissions.has(perm)\n    );\n\n    return {\n        canSend: missingPermissions.length === 0,\n        missingPermissions: missingPermissions,\n        reason:\n            missingPermissions.length > 0\n                ? `Missing permissions: ${missingPermissions.map((p) => String(p)).join(\", \")}`\n                : null,\n    };\n}\n\nexport class MessageManager {\n    private client: Client;\n    private runtime: IAgentRuntime;\n    private attachmentManager: AttachmentManager;\n    private interestChannels: InterestChannels = {};\n    private discordClient: any;\n    private voiceManager: VoiceManager;\n\n    constructor(discordClient: any, voiceManager: VoiceManager) {\n        this.client = discordClient.client;\n        this.voiceManager = voiceManager;\n        this.discordClient = discordClient;\n        this.runtime = discordClient.runtime;\n        this.attachmentManager = new AttachmentManager(this.runtime);\n    }\n\n    async handleMessage(message: DiscordMessage) {\n        if (\n            message.interaction ||\n            message.author.id ===\n                this.client.user?.id /* || message.author?.bot*/\n        )\n            return;\n\n        if (\n            this.runtime.character.clientConfig?.discord\n                ?.shouldIgnoreBotMessages &&\n            message.author?.bot\n        ) {\n            return;\n        }\n\n        if (\n            this.runtime.character.clientConfig?.discord\n                ?.shouldIgnoreDirectMessages &&\n            message.channel.type === ChannelType.DM\n        ) {\n            return;\n        }\n\n        const userId = message.author.id as UUID;\n        const userName = message.author.username;\n        const name = message.author.displayName;\n        const channelId = message.channel.id;\n\n        try {\n            const { processedContent, attachments } =\n                await this.processMessageMedia(message);\n\n            const audioAttachments = message.attachments.filter((attachment) =>\n                attachment.contentType?.startsWith(\"audio/\")\n            );\n            if (audioAttachments.size > 0) {\n                const processedAudioAttachments =\n                    await this.attachmentManager.processAttachments(\n                        audioAttachments\n                    );\n                attachments.push(...processedAudioAttachments);\n            }\n\n            const roomId = stringToUuid(channelId + \"-\" + this.runtime.agentId);\n            const userIdUUID = stringToUuid(userId);\n\n            await this.runtime.ensureConnection(\n                userIdUUID,\n                roomId,\n                userName,\n                name,\n                \"discord\"\n            );\n\n            const messageId = stringToUuid(\n                message.id + \"-\" + this.runtime.agentId\n            );\n\n            let shouldIgnore = false;\n            let shouldRespond = true;\n\n            const content: Content = {\n                text: processedContent,\n                attachments: attachments,\n                source: \"discord\",\n                url: message.url,\n                inReplyTo: message.reference?.messageId\n                    ? stringToUuid(\n                          message.reference.messageId +\n                              \"-\" +\n                              this.runtime.agentId\n                      )\n                    : undefined,\n            };\n\n            const userMessage = {\n                content,\n                userId: userIdUUID,\n                agentId: this.runtime.agentId,\n                roomId,\n            };\n\n            const memory: Memory = {\n                id: stringToUuid(message.id + \"-\" + this.runtime.agentId),\n                ...userMessage,\n                userId: userIdUUID,\n                agentId: this.runtime.agentId,\n                roomId,\n                content,\n                createdAt: message.createdTimestamp,\n            };\n\n            if (content.text) {\n                await this.runtime.messageManager.addEmbeddingToMemory(memory);\n                await this.runtime.messageManager.createMemory(memory);\n            }\n\n            let state = await this.runtime.composeState(userMessage, {\n                discordClient: this.client,\n                discordMessage: message,\n                agentName:\n                    this.runtime.character.name ||\n                    this.client.user?.displayName,\n            });\n\n            if (!canSendMessage(message.channel).canSend) {\n                return elizaLogger.warn(\n                    `Cannot send message to channel ${message.channel}`,\n                    canSendMessage(message.channel)\n                );\n            }\n\n            if (!shouldIgnore) {\n                shouldIgnore = await this._shouldIgnore(message);\n            }\n\n            if (shouldIgnore) {\n                return;\n            }\n            const hasInterest = this._checkInterest(channelId);\n\n            const agentUserState =\n                await this.runtime.databaseAdapter.getParticipantUserState(\n                    roomId,\n                    this.runtime.agentId\n                );\n\n            if (\n                agentUserState === \"MUTED\" &&\n                !message.mentions.has(this.client.user.id) &&\n                !hasInterest\n            ) {\n                console.log(\"Ignoring muted room\");\n                // Ignore muted rooms unless explicitly mentioned\n                return;\n            }\n\n            if (agentUserState === \"FOLLOWED\") {\n                shouldRespond = true; // Always respond in followed rooms\n            } else if (\n                (!shouldRespond && hasInterest) ||\n                (shouldRespond && !hasInterest)\n            ) {\n                shouldRespond = await this._shouldRespond(message, state);\n            }\n\n            if (shouldRespond) {\n                const context = composeContext({\n                    state,\n                    template:\n                        this.runtime.character.templates\n                            ?.discordMessageHandlerTemplate ||\n                        discordMessageHandlerTemplate,\n                });\n\n                const responseContent = await this._generateResponse(\n                    memory,\n                    state,\n                    context\n                );\n\n                responseContent.text = responseContent.text?.trim();\n                responseContent.inReplyTo = stringToUuid(\n                    message.id + \"-\" + this.runtime.agentId\n                );\n\n                if (!responseContent.text) {\n                    return;\n                }\n\n                const callback: HandlerCallback = async (\n                    content: Content,\n                    files: any[]\n                ) => {\n                    try {\n                        if (message.id && !content.inReplyTo) {\n                            content.inReplyTo = stringToUuid(\n                                message.id + \"-\" + this.runtime.agentId\n                            );\n                        }\n                        if (message.channel.type === ChannelType.GuildVoice) {\n                            // For voice channels, use text-to-speech\n\n                            const speechService =\n                                this.runtime.getService<ISpeechService>(\n                                    ServiceType.SPEECH_GENERATION\n                                );\n\n                            if (!speechService) {\n                                throw new Error(\n                                    \"Speech generation service not found\"\n                                );\n                            }\n\n                            const audioStream = await speechService.generate(\n                                this.runtime,\n                                content.text\n                            );\n\n                            await this.voiceManager.playAudioStream(\n                                userId,\n                                audioStream\n                            );\n                            const memory: Memory = {\n                                id: stringToUuid(\n                                    message.id + \"-\" + this.runtime.agentId\n                                ),\n                                userId: this.runtime.agentId,\n                                agentId: this.runtime.agentId,\n                                content,\n                                roomId,\n                                embedding: embeddingZeroVector,\n                            };\n                            return [memory];\n                        } else {\n                            // For text channels, send the message\n                            const messages = await sendMessageInChunks(\n                                message.channel as TextChannel,\n                                content.text,\n                                message.id,\n                                files\n                            );\n\n                            const memories: Memory[] = [];\n                            for (const m of messages) {\n                                let action = content.action;\n                                // If there's only one message or it's the last message, keep the original action\n                                // For multiple messages, set all but the last to 'CONTINUE'\n                                if (\n                                    messages.length > 1 &&\n                                    m !== messages[messages.length - 1]\n                                ) {\n                                    action = \"CONTINUE\";\n                                }\n\n                                const memory: Memory = {\n                                    id: stringToUuid(\n                                        m.id + \"-\" + this.runtime.agentId\n                                    ),\n                                    userId: this.runtime.agentId,\n                                    agentId: this.runtime.agentId,\n                                    content: {\n                                        ...content,\n                                        action,\n                                        inReplyTo: messageId,\n                                        url: m.url,\n                                    },\n                                    roomId,\n                                    embedding: embeddingZeroVector,\n                                    createdAt: m.createdTimestamp,\n                                };\n                                memories.push(memory);\n                            }\n                            for (const m of memories) {\n                                await this.runtime.messageManager.createMemory(\n                                    m\n                                );\n                            }\n                            return memories;\n                        }\n                    } catch (error) {\n                        console.error(\"Error sending message:\", error);\n                        return [];\n                    }\n                };\n\n                const responseMessages = await callback(responseContent);\n\n                state = await this.runtime.updateRecentMessageState(state);\n\n                await this.runtime.processActions(\n                    memory,\n                    responseMessages,\n                    state,\n                    callback\n                );\n            }\n            await this.runtime.evaluate(memory, state, shouldRespond);\n        } catch (error) {\n            console.error(\"Error handling message:\", error);\n            if (message.channel.type === ChannelType.GuildVoice) {\n                // For voice channels, use text-to-speech for the error message\n                const errorMessage = \"Sorry, I had a glitch. What was that?\";\n\n                const speechService = this.runtime.getService<ISpeechService>(\n                    ServiceType.SPEECH_GENERATION\n                );\n                if (!speechService) {\n                    throw new Error(\"Speech generation service not found\");\n                }\n\n                const audioStream = await speechService.generate(\n                    this.runtime,\n                    errorMessage\n                );\n                await this.voiceManager.playAudioStream(userId, audioStream);\n            } else {\n                // For text channels, send the error message\n                console.error(\"Error sending message:\", error);\n            }\n        }\n    }\n\n    async cacheMessages(channel: TextChannel, count: number = 20) {\n        const messages = await channel.messages.fetch({ limit: count });\n\n        // TODO: This is throwing an error but seems to work?\n        for (const [_, message] of messages) {\n            await this.handleMessage(message);\n        }\n    }\n\n    async processMessageMedia(\n        message: DiscordMessage\n    ): Promise<{ processedContent: string; attachments: Media[] }> {\n        let processedContent = message.content;\n\n        let attachments: Media[] = [];\n\n        // Process code blocks in the message content\n        const codeBlockRegex = /```([\\s\\S]*?)```/g;\n        let match;\n        while ((match = codeBlockRegex.exec(processedContent))) {\n            const codeBlock = match[1];\n            const lines = codeBlock.split(\"\\n\");\n            const title = lines[0];\n            const description = lines.slice(0, 3).join(\"\\n\");\n            const attachmentId =\n                `code-${Date.now()}-${Math.floor(Math.random() * 1000)}`.slice(\n                    -5\n                );\n            attachments.push({\n                id: attachmentId,\n                url: \"\",\n                title: title || \"Code Block\",\n                source: \"Code\",\n                description: description,\n                text: codeBlock,\n            });\n            processedContent = processedContent.replace(\n                match[0],\n                `Code Block (${attachmentId})`\n            );\n        }\n\n        // Process message attachments\n        if (message.attachments.size > 0) {\n            attachments = await this.attachmentManager.processAttachments(\n                message.attachments\n            );\n        }\n\n        // TODO: Move to attachments manager\n        const urlRegex = /(https?:\\/\\/[^\\s]+)/g;\n        const urls = processedContent.match(urlRegex) || [];\n\n        for (const url of urls) {\n            if (\n                this.runtime\n                    .getService<IVideoService>(ServiceType.VIDEO)\n                    .isVideoUrl(url)\n            ) {\n                const videoService = this.runtime.getService<IVideoService>(\n                    ServiceType.VIDEO\n                );\n                if (!videoService) {\n                    throw new Error(\"Video service not found\");\n                }\n                const videoInfo = await videoService.processVideo(url);\n\n                attachments.push({\n                    id: `youtube-${Date.now()}`,\n                    url: url,\n                    title: videoInfo.title,\n                    source: \"YouTube\",\n                    description: videoInfo.description,\n                    text: videoInfo.text,\n                });\n            } else {\n                const browserService = this.runtime.getService<IBrowserService>(\n                    ServiceType.BROWSER\n                );\n                if (!browserService) {\n                    throw new Error(\"Browser service not found\");\n                }\n\n                const { title, bodyContent } =\n                    await browserService.getPageContent(url, this.runtime);\n\n                const { title: newTitle, description } = await generateSummary(\n                    this.runtime,\n                    title + \"\\n\" + bodyContent\n                );\n                attachments.push({\n                    id: `webpage-${Date.now()}`,\n                    url: url,\n                    title: newTitle || \"Web Page\",\n                    source: \"Web\",\n                    description,\n                    text: bodyContent,\n                });\n            }\n        }\n\n        return { processedContent, attachments };\n    }\n\n    private _checkInterest(channelId: string): boolean {\n        return !!this.interestChannels[channelId];\n    }\n\n    private async _shouldIgnore(message: DiscordMessage): Promise<boolean> {\n        // if the message is from us, ignore\n        if (message.author.id === this.client.user?.id) return true;\n        let messageContent = message.content.toLowerCase();\n\n        // Replace the bot's @ping with the character name\n        const botMention = `<@!?${this.client.user?.id}>`;\n        messageContent = messageContent.replace(\n            new RegExp(botMention, \"gi\"),\n            this.runtime.character.name.toLowerCase()\n        );\n\n        // Replace the bot's username with the character name\n        const botUsername = this.client.user?.username.toLowerCase();\n        messageContent = messageContent.replace(\n            new RegExp(`\\\\b${botUsername}\\\\b`, \"g\"),\n            this.runtime.character.name.toLowerCase()\n        );\n\n        // strip all special characters\n        messageContent = messageContent.replace(/[^a-zA-Z0-9\\s]/g, \"\");\n\n        // short responses where ruby should stop talking and disengage unless mentioned again\n        const loseInterestWords = [\n            \"shut up\",\n            \"stop\",\n            \"please shut up\",\n            \"shut up please\",\n            \"dont talk\",\n            \"silence\",\n            \"stop talking\",\n            \"be quiet\",\n            \"hush\",\n            \"wtf\",\n            \"chill\",\n            \"stfu\",\n            \"stupid bot\",\n            \"dumb bot\",\n            \"stop responding\",\n            \"god damn it\",\n            \"god damn\",\n            \"goddamnit\",\n            \"can you not\",\n            \"can you stop\",\n            \"be quiet\",\n            \"hate you\",\n            \"hate this\",\n            \"fuck up\",\n        ];\n        if (\n            messageContent.length < 100 &&\n            loseInterestWords.some((word) => messageContent.includes(word))\n        ) {\n            delete this.interestChannels[message.channelId];\n            return true;\n        }\n\n        // If we're not interested in the channel and it's a short message, ignore it\n        if (\n            messageContent.length < 10 &&\n            !this.interestChannels[message.channelId]\n        ) {\n            return true;\n        }\n\n        const targetedPhrases = [\n            this.runtime.character.name + \" stop responding\",\n            this.runtime.character.name + \" stop talking\",\n            this.runtime.character.name + \" shut up\",\n            this.runtime.character.name + \" stfu\",\n            \"stop talking\" + this.runtime.character.name,\n            this.runtime.character.name + \" stop talking\",\n            \"shut up \" + this.runtime.character.name,\n            this.runtime.character.name + \" shut up\",\n            \"stfu \" + this.runtime.character.name,\n            this.runtime.character.name + \" stfu\",\n            \"chill\" + this.runtime.character.name,\n            this.runtime.character.name + \" chill\",\n        ];\n\n        // lose interest if pinged and told to stop responding\n        if (targetedPhrases.some((phrase) => messageContent.includes(phrase))) {\n            delete this.interestChannels[message.channelId];\n            return true;\n        }\n\n        // if the message is short, ignore but maintain interest\n        if (\n            !this.interestChannels[message.channelId] &&\n            messageContent.length < 2\n        ) {\n            return true;\n        }\n\n        const ignoreResponseWords = [\n            \"lol\",\n            \"nm\",\n            \"uh\",\n            \"wtf\",\n            \"stfu\",\n            \"dumb\",\n            \"jfc\",\n            \"omg\",\n        ];\n        if (\n            message.content.length < 4 &&\n            ignoreResponseWords.some((word) =>\n                message.content.toLowerCase().includes(word)\n            )\n        ) {\n            return true;\n        }\n        return false;\n    }\n\n    private async _shouldRespond(\n        message: DiscordMessage,\n        state: State\n    ): Promise<boolean> {\n        if (message.author.id === this.client.user?.id) return false;\n        // if (message.author.bot) return false;\n        if (message.mentions.has(this.client.user?.id as string)) return true;\n\n        const guild = message.guild;\n        const member = guild?.members.cache.get(this.client.user?.id as string);\n        const nickname = member?.nickname;\n\n        if (\n            message.content\n                .toLowerCase()\n                .includes(this.client.user?.username.toLowerCase() as string) ||\n            message.content\n                .toLowerCase()\n                .includes(this.client.user?.tag.toLowerCase() as string) ||\n            (nickname &&\n                message.content.toLowerCase().includes(nickname.toLowerCase()))\n        ) {\n            return true;\n        }\n\n        if (!message.guild) {\n            return true;\n        }\n\n        // If none of the above conditions are met, use the generateText to decide\n        const shouldRespondContext = composeContext({\n            state,\n            template:\n                this.runtime.character.templates\n                    ?.discordShouldRespondTemplate ||\n                this.runtime.character.templates?.shouldRespondTemplate ||\n                discordShouldRespondTemplate,\n        });\n\n        const response = await generateShouldRespond({\n            runtime: this.runtime,\n            context: shouldRespondContext,\n            modelClass: ModelClass.SMALL,\n        });\n\n        if (response === \"RESPOND\") {\n            return true;\n        } else if (response === \"IGNORE\") {\n            return false;\n        } else if (response === \"STOP\") {\n            delete this.interestChannels[message.channelId];\n            return false;\n        } else {\n            console.error(\n                \"Invalid response from response generateText:\",\n                response\n            );\n            return false;\n        }\n    }\n\n    private async _generateResponse(\n        message: Memory,\n        state: State,\n        context: string\n    ): Promise<Content> {\n        const { userId, roomId } = message;\n\n        const response = await generateMessageResponse({\n            runtime: this.runtime,\n            context,\n            modelClass: ModelClass.SMALL,\n        });\n\n        if (!response) {\n            console.error(\"No response from generateMessageResponse\");\n            return;\n        }\n\n        await this.runtime.databaseAdapter.log({\n            body: { message, context, response },\n            userId: userId,\n            roomId,\n            type: \"response\",\n        });\n\n        return response;\n    }\n\n    async fetchBotName(botToken: string) {\n        const url = \"https://discord.com/api/v10/users/@me\";\n\n        const response = await fetch(url, {\n            method: \"GET\",\n            headers: {\n                Authorization: `Bot ${botToken}`,\n            },\n        });\n\n        if (!response.ok) {\n            throw new Error(\n                `Error fetching bot details: ${response.statusText}`\n            );\n        }\n\n        const data = await response.json();\n        return data.username;\n    }\n}\n","import { generateText, trimTokens } from \"@ai16z/eliza\";\nimport { parseJSONObjectFromText } from \"@ai16z/eliza\";\nimport {\n    IAgentRuntime,\n    IImageDescriptionService,\n    IPdfService,\n    ITranscriptionService,\n    IVideoService,\n    Media,\n    ModelClass,\n    Service,\n    ServiceType,\n} from \"@ai16z/eliza\";\nimport { Attachment, Collection } from \"discord.js\";\nimport ffmpeg from \"fluent-ffmpeg\";\nimport fs from \"fs\";\n\nasync function generateSummary(\n    runtime: IAgentRuntime,\n    text: string\n): Promise<{ title: string; description: string }> {\n    // make sure text is under 128k characters\n    text = trimTokens(text, 100000, \"gpt-4o-mini\"); // TODO: clean this up\n\n    const prompt = `Please generate a concise summary for the following text:\n  \n  Text: \"\"\"\n  ${text}\n  \"\"\"\n  \n  Respond with a JSON object in the following format:\n  \\`\\`\\`json\n  {\n    \"title\": \"Generated Title\",\n    \"summary\": \"Generated summary and/or description of the text\"\n  }\n  \\`\\`\\``;\n\n    const response = await generateText({\n        runtime,\n        context: prompt,\n        modelClass: ModelClass.SMALL,\n    });\n\n    const parsedResponse = parseJSONObjectFromText(response);\n\n    if (parsedResponse) {\n        return {\n            title: parsedResponse.title,\n            description: parsedResponse.summary,\n        };\n    }\n\n    return {\n        title: \"\",\n        description: \"\",\n    };\n}\n\nexport class AttachmentManager {\n    private attachmentCache: Map<string, Media> = new Map();\n    private runtime: IAgentRuntime;\n\n    constructor(runtime: IAgentRuntime) {\n        this.runtime = runtime;\n    }\n\n    async processAttachments(\n        attachments: Collection<string, Attachment> | Attachment[]\n    ): Promise<Media[]> {\n        const processedAttachments: Media[] = [];\n        const attachmentCollection =\n            attachments instanceof Collection\n                ? attachments\n                : new Collection(attachments.map((att) => [att.id, att]));\n\n        for (const [, attachment] of attachmentCollection) {\n            const media = await this.processAttachment(attachment);\n            if (media) {\n                processedAttachments.push(media);\n            }\n        }\n\n        return processedAttachments;\n    }\n\n    async processAttachment(attachment: Attachment): Promise<Media | null> {\n        if (this.attachmentCache.has(attachment.url)) {\n            return this.attachmentCache.get(attachment.url)!;\n        }\n\n        let media: Media | null = null;\n        if (attachment.contentType?.startsWith(\"application/pdf\")) {\n            media = await this.processPdfAttachment(attachment);\n        } else if (attachment.contentType?.startsWith(\"text/plain\")) {\n            media = await this.processPlaintextAttachment(attachment);\n        } else if (\n            attachment.contentType?.startsWith(\"audio/\") ||\n            attachment.contentType?.startsWith(\"video/mp4\")\n        ) {\n            media = await this.processAudioVideoAttachment(attachment);\n        } else if (attachment.contentType?.startsWith(\"image/\")) {\n            media = await this.processImageAttachment(attachment);\n        } else if (\n            attachment.contentType?.startsWith(\"video/\") ||\n            this.runtime\n                .getService<IVideoService>(ServiceType.VIDEO)\n                .isVideoUrl(attachment.url)\n        ) {\n            media = await this.processVideoAttachment(attachment);\n        } else {\n            media = await this.processGenericAttachment(attachment);\n        }\n\n        if (media) {\n            this.attachmentCache.set(attachment.url, media);\n        }\n        return media;\n    }\n\n    private async processAudioVideoAttachment(\n        attachment: Attachment\n    ): Promise<Media> {\n        try {\n            const response = await fetch(attachment.url);\n            const audioVideoArrayBuffer = await response.arrayBuffer();\n\n            let audioBuffer: Buffer;\n            if (attachment.contentType?.startsWith(\"audio/\")) {\n                audioBuffer = Buffer.from(audioVideoArrayBuffer);\n            } else if (attachment.contentType?.startsWith(\"video/mp4\")) {\n                audioBuffer = await this.extractAudioFromMP4(\n                    audioVideoArrayBuffer\n                );\n            } else {\n                throw new Error(\"Unsupported audio/video format\");\n            }\n\n            const transcriptionService =\n                this.runtime.getService<ITranscriptionService>(\n                    ServiceType.TRANSCRIPTION\n                );\n            if (!transcriptionService) {\n                throw new Error(\"Transcription service not found\");\n            }\n\n            const transcription =\n                await transcriptionService.transcribeAttachment(audioBuffer);\n            const { title, description } = await generateSummary(\n                this.runtime,\n                transcription\n            );\n\n            return {\n                id: attachment.id,\n                url: attachment.url,\n                title: title || \"Audio/Video Attachment\",\n                source: attachment.contentType?.startsWith(\"audio/\")\n                    ? \"Audio\"\n                    : \"Video\",\n                description:\n                    description ||\n                    \"User-uploaded audio/video attachment which has been transcribed\",\n                text: transcription || \"Audio/video content not available\",\n            };\n        } catch (error) {\n            console.error(\n                `Error processing audio/video attachment: ${error.message}`\n            );\n            return {\n                id: attachment.id,\n                url: attachment.url,\n                title: \"Audio/Video Attachment\",\n                source: attachment.contentType?.startsWith(\"audio/\")\n                    ? \"Audio\"\n                    : \"Video\",\n                description: \"An audio/video attachment (transcription failed)\",\n                text: `This is an audio/video attachment. File name: ${attachment.name}, Size: ${attachment.size} bytes, Content type: ${attachment.contentType}`,\n            };\n        }\n    }\n\n    private async extractAudioFromMP4(mp4Data: ArrayBuffer): Promise<Buffer> {\n        // Use a library like 'fluent-ffmpeg' or 'ffmpeg-static' to extract the audio stream from the MP4 data\n        // and convert it to MP3 or WAV format\n        // Example using fluent-ffmpeg:\n        const tempMP4File = `temp_${Date.now()}.mp4`;\n        const tempAudioFile = `temp_${Date.now()}.mp3`;\n\n        try {\n            // Write the MP4 data to a temporary file\n            fs.writeFileSync(tempMP4File, Buffer.from(mp4Data));\n\n            // Extract the audio stream and convert it to MP3\n            await new Promise<void>((resolve, reject) => {\n                ffmpeg(tempMP4File)\n                    .outputOptions(\"-vn\") // Disable video output\n                    .audioCodec(\"libmp3lame\") // Set audio codec to MP3\n                    .save(tempAudioFile) // Save the output to the specified file\n                    .on(\"end\", () => {\n                        resolve();\n                    })\n                    .on(\"error\", (err) => {\n                        reject(err);\n                    })\n                    .run();\n            });\n\n            // Read the converted audio file and return it as a Buffer\n            const audioData = fs.readFileSync(tempAudioFile);\n            return audioData;\n        } finally {\n            // Clean up the temporary files\n            if (fs.existsSync(tempMP4File)) {\n                fs.unlinkSync(tempMP4File);\n            }\n            if (fs.existsSync(tempAudioFile)) {\n                fs.unlinkSync(tempAudioFile);\n            }\n        }\n    }\n\n    private async processPdfAttachment(attachment: Attachment): Promise<Media> {\n        try {\n            const response = await fetch(attachment.url);\n            const pdfBuffer = await response.arrayBuffer();\n            const text = await this.runtime\n                .getService<IPdfService>(ServiceType.PDF)\n                .convertPdfToText(Buffer.from(pdfBuffer));\n            const { title, description } = await generateSummary(\n                this.runtime,\n                text\n            );\n\n            return {\n                id: attachment.id,\n                url: attachment.url,\n                title: title || \"PDF Attachment\",\n                source: \"PDF\",\n                description: description || \"A PDF document\",\n                text: text,\n            };\n        } catch (error) {\n            console.error(`Error processing PDF attachment: ${error.message}`);\n            return {\n                id: attachment.id,\n                url: attachment.url,\n                title: \"PDF Attachment (conversion failed)\",\n                source: \"PDF\",\n                description:\n                    \"A PDF document that could not be converted to text\",\n                text: `This is a PDF attachment. File name: ${attachment.name}, Size: ${attachment.size} bytes`,\n            };\n        }\n    }\n\n    private async processPlaintextAttachment(\n        attachment: Attachment\n    ): Promise<Media> {\n        try {\n            const response = await fetch(attachment.url);\n            const text = await response.text();\n            const { title, description } = await generateSummary(\n                this.runtime,\n                text\n            );\n\n            return {\n                id: attachment.id,\n                url: attachment.url,\n                title: title || \"Plaintext Attachment\",\n                source: \"Plaintext\",\n                description: description || \"A plaintext document\",\n                text: text,\n            };\n        } catch (error) {\n            console.error(\n                `Error processing plaintext attachment: ${error.message}`\n            );\n            return {\n                id: attachment.id,\n                url: attachment.url,\n                title: \"Plaintext Attachment (retrieval failed)\",\n                source: \"Plaintext\",\n                description: \"A plaintext document that could not be retrieved\",\n                text: `This is a plaintext attachment. File name: ${attachment.name}, Size: ${attachment.size} bytes`,\n            };\n        }\n    }\n\n    private async processImageAttachment(\n        attachment: Attachment\n    ): Promise<Media> {\n        try {\n            const { description, title } = await this.runtime\n                .getService<IImageDescriptionService>(\n                    ServiceType.IMAGE_DESCRIPTION\n                )\n                .describeImage(attachment.url);\n            return {\n                id: attachment.id,\n                url: attachment.url,\n                title: title || \"Image Attachment\",\n                source: \"Image\",\n                description: description || \"An image attachment\",\n                text: description || \"Image content not available\",\n            };\n        } catch (error) {\n            console.error(\n                `Error processing image attachment: ${error.message}`\n            );\n            return this.createFallbackImageMedia(attachment);\n        }\n    }\n\n    private createFallbackImageMedia(attachment: Attachment): Media {\n        return {\n            id: attachment.id,\n            url: attachment.url,\n            title: \"Image Attachment\",\n            source: \"Image\",\n            description: \"An image attachment (recognition failed)\",\n            text: `This is an image attachment. File name: ${attachment.name}, Size: ${attachment.size} bytes, Content type: ${attachment.contentType}`,\n        };\n    }\n\n    private async processVideoAttachment(\n        attachment: Attachment\n    ): Promise<Media> {\n        const videoService = this.runtime.getService<IVideoService>(\n            ServiceType.VIDEO\n        );\n\n        if (!videoService) {\n            throw new Error(\"Video service not found\");\n        }\n\n        if (videoService.isVideoUrl(attachment.url)) {\n            const videoInfo = await videoService.processVideo(attachment.url);\n            return {\n                id: attachment.id,\n                url: attachment.url,\n                title: videoInfo.title,\n                source: \"YouTube\",\n                description: videoInfo.description,\n                text: videoInfo.text,\n            };\n        } else {\n            return {\n                id: attachment.id,\n                url: attachment.url,\n                title: \"Video Attachment\",\n                source: \"Video\",\n                description: \"A video attachment\",\n                text: \"Video content not available\",\n            };\n        }\n    }\n\n    private async processGenericAttachment(\n        attachment: Attachment\n    ): Promise<Media> {\n        return {\n            id: attachment.id,\n            url: attachment.url,\n            title: \"Generic Attachment\",\n            source: \"Generic\",\n            description: \"A generic attachment\",\n            text: \"Attachment content not available\",\n        };\n    }\n}\n","import {\n    ChannelType,\n    Message as DiscordMessage,\n    TextChannel,\n} from \"discord.js\";\nimport { IAgentRuntime, Memory, Provider, State } from \"@ai16z/eliza\";\n\nconst channelStateProvider: Provider = {\n    get: async (runtime: IAgentRuntime, message: Memory, state?: State) => {\n        const discordMessage =\n            (state?.discordMessage as DiscordMessage) ||\n            (state?.discordChannel as DiscordMessage);\n        if (!discordMessage) {\n            return \"\";\n        }\n\n        const guild = discordMessage?.guild;\n        const agentName = state?.agentName || \"The agent\";\n        const senderName = state?.senderName || \"someone\";\n\n        if (!guild) {\n            return (\n                agentName +\n                \" is currently in a direct message conversation with \" +\n                senderName\n            );\n        }\n\n        const serverName = guild.name; // The name of the server\n        const guildId = guild.id; // The ID of the guild\n        const channel = discordMessage.channel;\n\n        if (!channel) {\n            console.log(\"channel is null\");\n            return \"\";\n        }\n\n        let response =\n            agentName +\n            \" is currently having a conversation in the channel `@\" +\n            channel.id +\n            \" in the server `\" +\n            serverName +\n            \"` (@\" +\n            guildId +\n            \")\";\n        if (\n            channel.type === ChannelType.GuildText &&\n            (channel as TextChannel).topic\n        ) {\n            // Check if the channel is a text channel\n            response +=\n                \"\\nThe topic of the channel is: \" +\n                (channel as TextChannel).topic;\n        }\n        return response;\n    },\n};\n\nexport default channelStateProvider;\n","import { getVoiceConnection } from \"@discordjs/voice\";\nimport { ChannelType, Message as DiscordMessage } from \"discord.js\";\nimport { IAgentRuntime, Memory, Provider, State } from \"@ai16z/eliza\";\n\nconst voiceStateProvider: Provider = {\n    get: async (runtime: IAgentRuntime, message: Memory, state?: State) => {\n        // Voice doesn't get a discord message, so we need to use the channel for guild data\n        const discordMessage = (state?.discordMessage ||\n            state.discordChannel) as DiscordMessage;\n        const connection = getVoiceConnection(\n            (discordMessage as DiscordMessage)?.guild?.id as string\n        );\n        const agentName = state?.agentName || \"The agent\";\n        if (!connection) {\n            return agentName + \" is not currently in a voice channel\";\n        }\n\n        const channel = (\n            (state?.discordMessage as DiscordMessage) ||\n            (state.discordChannel as DiscordMessage)\n        )?.guild?.channels?.cache?.get(\n            connection.joinConfig.channelId as string\n        );\n\n        if (!channel || channel.type !== ChannelType.GuildVoice) {\n            return agentName + \" is in an invalid voice channel\";\n        }\n\n        return `${agentName} is currently in the voice channel: ${channel.name} (ID: ${channel.id})`;\n    },\n};\n\nexport default voiceStateProvider;\n","import {\n    Content,\n    HandlerCallback,\n    IAgentRuntime,\n    ISpeechService,\n    ITranscriptionService,\n    Memory,\n    ModelClass,\n    ServiceType,\n    State,\n    UUID,\n    composeContext,\n    elizaLogger,\n    embeddingZeroVector,\n    generateMessageResponse,\n    messageCompletionFooter,\n    stringToUuid,\n} from \"@ai16z/eliza\";\nimport {\n    AudioReceiveStream,\n    NoSubscriberBehavior,\n    StreamType,\n    VoiceConnection,\n    createAudioPlayer,\n    createAudioResource,\n    getVoiceConnection,\n    joinVoiceChannel,\n} from \"@discordjs/voice\";\nimport {\n    BaseGuildVoiceChannel,\n    ChannelType,\n    Client,\n    Guild,\n    GuildMember,\n    VoiceChannel,\n    VoiceState,\n} from \"discord.js\";\nimport EventEmitter from \"events\";\nimport prism from \"prism-media\";\nimport { Readable, pipeline } from \"stream\";\nimport { DiscordClient } from \"./index.ts\";\n\nexport function getWavHeader(\n    audioLength: number,\n    sampleRate: number,\n    channelCount: number = 1,\n    bitsPerSample: number = 16\n): Buffer {\n    const wavHeader = Buffer.alloc(44);\n    wavHeader.write(\"RIFF\", 0);\n    wavHeader.writeUInt32LE(36 + audioLength, 4); // Length of entire file in bytes minus 8\n    wavHeader.write(\"WAVE\", 8);\n    wavHeader.write(\"fmt \", 12);\n    wavHeader.writeUInt32LE(16, 16); // Length of format data\n    wavHeader.writeUInt16LE(1, 20); // Type of format (1 is PCM)\n    wavHeader.writeUInt16LE(channelCount, 22); // Number of channels\n    wavHeader.writeUInt32LE(sampleRate, 24); // Sample rate\n    wavHeader.writeUInt32LE(\n        (sampleRate * bitsPerSample * channelCount) / 8,\n        28\n    ); // Byte rate\n    wavHeader.writeUInt16LE((bitsPerSample * channelCount) / 8, 32); // Block align ((BitsPerSample * Channels) / 8)\n    wavHeader.writeUInt16LE(bitsPerSample, 34); // Bits per sample\n    wavHeader.write(\"data\", 36); // Data chunk header\n    wavHeader.writeUInt32LE(audioLength, 40); // Data chunk size\n    return wavHeader;\n}\n\nconst discordVoiceHandlerTemplate =\n    `# Task: Generate conversational voice dialog for {{agentName}}.\nAbout {{agentName}}:\n{{bio}}\n\n# Attachments\n{{attachments}}\n\n# Capabilities\nNote that {{agentName}} is capable of reading/seeing/hearing various forms of media, including images, videos, audio, plaintext and PDFs. Recent attachments have been included above under the \"Attachments\" section.\n\n{{actions}}\n\n{{messageDirections}}\n\n{{recentMessages}}\n\n# Instructions: Write the next message for {{agentName}}. Include an optional action if appropriate. {{actionNames}}\n` + messageCompletionFooter;\n\n// These values are chosen for compatibility with picovoice components\nconst DECODE_FRAME_SIZE = 1024;\nconst DECODE_SAMPLE_RATE = 16000;\n\n// Buffers all audio\nexport class AudioMonitor {\n    private readable: Readable;\n    private buffers: Buffer[] = [];\n    private maxSize: number;\n    private lastFlagged: number = -1;\n    private ended: boolean = false;\n\n    constructor(\n        readable: Readable,\n        maxSize: number,\n        callback: (buffer: Buffer) => void\n    ) {\n        this.readable = readable;\n        this.maxSize = maxSize;\n        this.readable.on(\"data\", (chunk: Buffer) => {\n            //console.log('AudioMonitor got data');\n            if (this.lastFlagged < 0) {\n                this.lastFlagged = this.buffers.length;\n            }\n            this.buffers.push(chunk);\n            const currentSize = this.buffers.reduce(\n                (acc, cur) => acc + cur.length,\n                0\n            );\n            while (currentSize > this.maxSize) {\n                this.buffers.shift();\n                this.lastFlagged--;\n            }\n        });\n        this.readable.on(\"end\", () => {\n            elizaLogger.log(\"AudioMonitor ended\");\n            this.ended = true;\n            if (this.lastFlagged < 0) return;\n            callback(this.getBufferFromStart());\n            this.lastFlagged = -1;\n        });\n        this.readable.on(\"speakingStopped\", () => {\n            if (this.ended) return;\n            elizaLogger.log(\"Speaking stopped\");\n            if (this.lastFlagged < 0) return;\n            callback(this.getBufferFromStart());\n        });\n        this.readable.on(\"speakingStarted\", () => {\n            if (this.ended) return;\n            elizaLogger.log(\"Speaking started\");\n            this.reset();\n        });\n    }\n\n    stop() {\n        this.readable.removeAllListeners(\"data\");\n        this.readable.removeAllListeners(\"end\");\n        this.readable.removeAllListeners(\"speakingStopped\");\n        this.readable.removeAllListeners(\"speakingStarted\");\n    }\n\n    isFlagged() {\n        return this.lastFlagged >= 0;\n    }\n\n    getBufferFromFlag() {\n        if (this.lastFlagged < 0) {\n            return null;\n        }\n        const buffer = Buffer.concat(this.buffers.slice(this.lastFlagged));\n        return buffer;\n    }\n\n    getBufferFromStart() {\n        const buffer = Buffer.concat(this.buffers);\n        return buffer;\n    }\n\n    reset() {\n        this.buffers = [];\n        this.lastFlagged = -1;\n    }\n\n    isEnded() {\n        return this.ended;\n    }\n}\n\nexport class VoiceManager extends EventEmitter {\n    private client: Client;\n    private runtime: IAgentRuntime;\n    private streams: Map<string, Readable> = new Map();\n    private connections: Map<string, VoiceConnection> = new Map();\n    private activeMonitors: Map<\n        string,\n        { channel: BaseGuildVoiceChannel; monitor: AudioMonitor }\n    > = new Map();\n\n    constructor(client: DiscordClient) {\n        super();\n        this.client = client.client;\n        this.runtime = client.runtime;\n    }\n\n    async handleVoiceStateUpdate(oldState: VoiceState, newState: VoiceState) {\n        const oldChannelId = oldState.channelId;\n        const newChannelId = newState.channelId;\n        const member = newState.member;\n        if (!member) return;\n        if (member.id === this.client.user?.id) {\n            return;\n        }\n\n        // Ignore mute/unmute events\n        if (oldChannelId === newChannelId) {\n            return;\n        }\n\n        // User leaving a channel where the bot is present\n        if (oldChannelId && this.connections.has(oldChannelId)) {\n            this.stopMonitoringMember(member.id);\n        }\n\n        // User joining a channel where the bot is present\n        if (newChannelId && this.connections.has(newChannelId)) {\n            await this.monitorMember(\n                member,\n                newState.channel as BaseGuildVoiceChannel\n            );\n        }\n    }\n\n    async joinChannel(channel: BaseGuildVoiceChannel) {\n        const oldConnection = getVoiceConnection(channel.guildId as string);\n        if (oldConnection) {\n            try {\n                oldConnection.destroy();\n                // Remove all associated streams and monitors\n                this.streams.clear();\n                this.activeMonitors.clear();\n            } catch (error) {\n                console.error(\"Error leaving voice channel:\", error);\n            }\n        }\n        const connection = joinVoiceChannel({\n            channelId: channel.id,\n            guildId: channel.guild.id,\n            adapterCreator: channel.guild.voiceAdapterCreator as any,\n            selfDeaf: false,\n            selfMute: false,\n        });\n\n        const me = channel.guild.members.me;\n        if (me?.voice && me.permissions.has(\"DeafenMembers\")) {\n            await me.voice.setDeaf(false);\n            await me.voice.setMute(false);\n        } else {\n            elizaLogger.log(\"Bot lacks permission to modify voice state\");\n        }\n\n        for (const [, member] of channel.members) {\n            if (!member.user.bot) {\n                this.monitorMember(member, channel);\n            }\n        }\n\n        connection.on(\"error\", (error) => {\n            console.error(\"Voice connection error:\", error);\n        });\n\n        connection.receiver.speaking.on(\"start\", (userId: string) => {\n            const user = channel.members.get(userId);\n            if (!user?.user.bot) {\n                this.monitorMember(user as GuildMember, channel);\n                this.streams.get(userId)?.emit(\"speakingStarted\");\n            }\n        });\n\n        connection.receiver.speaking.on(\"end\", async (userId: string) => {\n            const user = channel.members.get(userId);\n            if (!user?.user.bot) {\n                this.streams.get(userId)?.emit(\"speakingStopped\");\n            }\n        });\n    }\n\n    private async monitorMember(\n        member: GuildMember,\n        channel: BaseGuildVoiceChannel\n    ) {\n        const userId = member?.id;\n        const userName = member?.user?.username;\n        const name = member?.user?.displayName;\n        const connection = getVoiceConnection(member?.guild?.id);\n        const receiveStream = connection?.receiver.subscribe(userId, {\n            autoDestroy: true,\n            emitClose: true,\n        });\n        if (!receiveStream || receiveStream.readableLength === 0) {\n            return;\n        }\n        const opusDecoder = new prism.opus.Decoder({\n            channels: 1,\n            rate: DECODE_SAMPLE_RATE,\n            frameSize: DECODE_FRAME_SIZE,\n        });\n        pipeline(\n            receiveStream as AudioReceiveStream,\n            opusDecoder as any,\n            (err: Error | null) => {\n                if (err) {\n                    console.log(`Opus decoding pipeline error: ${err}`);\n                }\n            }\n        );\n        this.streams.set(userId, opusDecoder);\n        this.connections.set(userId, connection as VoiceConnection);\n        opusDecoder.on(\"error\", (err: any) => {\n            console.log(`Opus decoding error: ${err}`);\n        });\n        const errorHandler = (err: any) => {\n            console.log(`Opus decoding error: ${err}`);\n        };\n        const streamCloseHandler = () => {\n            console.log(`voice stream from ${member?.displayName} closed`);\n            this.streams.delete(userId);\n            this.connections.delete(userId);\n        };\n        const closeHandler = () => {\n            console.log(`Opus decoder for ${member?.displayName} closed`);\n            opusDecoder.removeListener(\"error\", errorHandler);\n            opusDecoder.removeListener(\"close\", closeHandler);\n            receiveStream?.removeListener(\"close\", streamCloseHandler);\n        };\n        opusDecoder.on(\"error\", errorHandler);\n        opusDecoder.on(\"close\", closeHandler);\n        receiveStream?.on(\"close\", streamCloseHandler);\n\n        this.client.emit(\n            \"userStream\",\n            userId,\n            name,\n            userName,\n            channel,\n            opusDecoder\n        );\n    }\n\n    leaveChannel(channel: BaseGuildVoiceChannel) {\n        const connection = this.connections.get(channel.id);\n        if (connection) {\n            connection.destroy();\n            this.connections.delete(channel.id);\n        }\n\n        // Stop monitoring all members in this channel\n        for (const [memberId, monitorInfo] of this.activeMonitors) {\n            if (\n                monitorInfo.channel.id === channel.id &&\n                memberId !== this.client.user?.id\n            ) {\n                this.stopMonitoringMember(memberId);\n            }\n        }\n\n        console.log(`Left voice channel: ${channel.name} (${channel.id})`);\n    }\n\n    stopMonitoringMember(memberId: string) {\n        const monitorInfo = this.activeMonitors.get(memberId);\n        if (monitorInfo) {\n            monitorInfo.monitor.stop();\n            this.activeMonitors.delete(memberId);\n            this.streams.delete(memberId);\n            console.log(`Stopped monitoring user ${memberId}`);\n        }\n    }\n\n    async handleGuildCreate(guild: Guild) {\n        console.log(`Joined guild ${guild.name}`);\n        // this.scanGuild(guild);\n    }\n\n    async handleUserStream(\n        userId: UUID,\n        name: string,\n        userName: string,\n        channel: BaseGuildVoiceChannel,\n        audioStream: Readable\n    ) {\n        const channelId = channel.id;\n        const buffers: Buffer[] = [];\n        let totalLength = 0;\n        const maxSilenceTime = 1000; // Maximum pause duration in milliseconds\n        const minSilenceTime = 50; // Minimum silence duration to trigger transcription\n        let lastChunkTime = Date.now();\n        let transcriptionStarted = false;\n        let transcriptionText = \"\";\n\n        const monitor = new AudioMonitor(\n            audioStream,\n            10000000,\n            async (buffer) => {\n                const currentTime = Date.now();\n                const silenceDuration = currentTime - lastChunkTime;\n                if (!buffer) {\n                    // Handle error\n                    console.error(\"Empty buffer received\");\n                    return;\n                }\n                buffers.push(buffer);\n                totalLength += buffer.length;\n                lastChunkTime = currentTime;\n\n                if (silenceDuration > minSilenceTime && !transcriptionStarted) {\n                    transcriptionStarted = true;\n                    const inputBuffer = Buffer.concat(buffers, totalLength);\n                    buffers.length = 0;\n                    totalLength = 0;\n\n                    try {\n                        // Convert Opus to WAV and add the header\n                        const wavBuffer =\n                            await this.convertOpusToWav(inputBuffer);\n\n                        const transcriptionService =\n                            this.runtime.getService<ITranscriptionService>(\n                                ServiceType.TRANSCRIPTION\n                            );\n\n                        if (!transcriptionService) {\n                            throw new Error(\n                                \"Transcription generation service not found\"\n                            );\n                        }\n\n                        const text =\n                            await transcriptionService.transcribe(wavBuffer);\n\n                        transcriptionText += text;\n                    } catch (error) {\n                        console.error(\"Error processing audio stream:\", error);\n                    }\n                }\n\n                if (silenceDuration > maxSilenceTime && transcriptionStarted) {\n                    console.log(\"transcription finished\");\n                    transcriptionStarted = false;\n\n                    if (!transcriptionText) return;\n\n                    try {\n                        const text = transcriptionText;\n\n                        // handle whisper cases\n                        if (\n                            (text.length < 15 &&\n                                text.includes(\"[BLANK_AUDIO]\")) ||\n                            (text.length < 5 &&\n                                text.toLowerCase().includes(\"you\"))\n                        ) {\n                            transcriptionText = \"\"; // Reset transcription text\n                            return;\n                        }\n\n                        const roomId = stringToUuid(\n                            channelId + \"-\" + this.runtime.agentId\n                        );\n                        const userIdUUID = stringToUuid(userId);\n\n                        await this.runtime.ensureConnection(\n                            userIdUUID,\n                            roomId,\n                            userName,\n                            name,\n                            \"discord\"\n                        );\n\n                        let state = await this.runtime.composeState(\n                            {\n                                agentId: this.runtime.agentId,\n                                content: { text: text, source: \"Discord\" },\n                                userId: userIdUUID,\n                                roomId,\n                            },\n                            {\n                                discordChannel: channel,\n                                discordClient: this.client,\n                                agentName: this.runtime.character.name,\n                            }\n                        );\n\n                        if (text && text.startsWith(\"/\")) {\n                            transcriptionText = \"\"; // Reset transcription text\n                            return null;\n                        }\n\n                        const memory = {\n                            id: stringToUuid(\n                                channelId + \"-voice-message-\" + Date.now()\n                            ),\n                            agentId: this.runtime.agentId,\n                            content: {\n                                text: text,\n                                source: \"discord\",\n                                url: channel.url,\n                            },\n                            userId: userIdUUID,\n                            roomId,\n                            embedding: embeddingZeroVector,\n                            createdAt: Date.now(),\n                        };\n\n                        if (!memory.content.text) {\n                            transcriptionText = \"\"; // Reset transcription text\n                            return { text: \"\", action: \"IGNORE\" };\n                        }\n\n                        await this.runtime.messageManager.createMemory(memory);\n\n                        state =\n                            await this.runtime.updateRecentMessageState(state);\n\n                        const shouldIgnore = await this._shouldIgnore(memory);\n\n                        if (shouldIgnore) {\n                            transcriptionText = \"\"; // Reset transcription text\n                            return { text: \"\", action: \"IGNORE\" };\n                        }\n\n                        const context = composeContext({\n                            state,\n                            template:\n                                this.runtime.character.templates\n                                    ?.discordVoiceHandlerTemplate ||\n                                this.runtime.character.templates\n                                    ?.messageHandlerTemplate ||\n                                discordVoiceHandlerTemplate,\n                        });\n\n                        const responseContent = await this._generateResponse(\n                            memory,\n                            state,\n                            context\n                        );\n\n                        const callback: HandlerCallback = async (\n                            content: Content\n                        ) => {\n                            elizaLogger.debug(\"callback content: \", content);\n                            const { roomId } = memory;\n\n                            const responseMemory: Memory = {\n                                id: stringToUuid(\n                                    memory.id + \"-voice-response-\" + Date.now()\n                                ),\n                                agentId: this.runtime.agentId,\n                                userId: this.runtime.agentId,\n                                content: {\n                                    ...content,\n                                    user: this.runtime.character.name,\n                                    inReplyTo: memory.id,\n                                },\n                                roomId,\n                                embedding: embeddingZeroVector,\n                            };\n\n                            if (responseMemory.content.text?.trim()) {\n                                await this.runtime.messageManager.createMemory(\n                                    responseMemory\n                                );\n                                state =\n                                    await this.runtime.updateRecentMessageState(\n                                        state\n                                    );\n\n                                const speechService =\n                                    this.runtime.getService<ISpeechService>(\n                                        ServiceType.SPEECH_GENERATION\n                                    );\n                                if (!speechService) {\n                                    throw new Error(\n                                        \"Speech generation service not found\"\n                                    );\n                                }\n\n                                const responseStream =\n                                    await speechService.generate(\n                                        this.runtime,\n                                        content.text\n                                    );\n\n                                if (responseStream) {\n                                    await this.playAudioStream(\n                                        userId,\n                                        responseStream as Readable\n                                    );\n                                }\n                                await this.runtime.evaluate(memory, state);\n                            } else {\n                                console.warn(\"Empty response, skipping\");\n                            }\n                            return [responseMemory];\n                        };\n\n                        const responseMemories =\n                            await callback(responseContent);\n\n                        const response = responseContent;\n\n                        const content = (response.responseMessage ||\n                            response.content ||\n                            response.message) as string;\n\n                        if (!content) {\n                            transcriptionText = \"\"; // Reset transcription text\n                            return null;\n                        }\n\n                        console.log(\"responseMemories: \", responseMemories);\n\n                        await this.runtime.processActions(\n                            memory,\n                            responseMemories,\n                            state,\n                            callback\n                        );\n\n                        transcriptionText = \"\"; // Reset transcription text\n                    } catch (error) {\n                        console.error(\n                            \"Error processing transcribed text:\",\n                            error\n                        );\n                        transcriptionText = \"\"; // Reset transcription text\n                    }\n                }\n            }\n        );\n    }\n\n    private async convertOpusToWav(pcmBuffer: Buffer): Promise<Buffer> {\n        try {\n            // Generate the WAV header\n            const wavHeader = getWavHeader(\n                pcmBuffer.length,\n                DECODE_SAMPLE_RATE\n            );\n\n            // Concatenate the WAV header and PCM data\n            const wavBuffer = Buffer.concat([wavHeader, pcmBuffer]);\n\n            return wavBuffer;\n        } catch (error) {\n            console.error(\"Error converting PCM to WAV:\", error);\n            throw error;\n        }\n    }\n\n    private async _generateResponse(\n        message: Memory,\n        state: State,\n        context: string\n    ): Promise<Content> {\n        const { userId, roomId } = message;\n\n        const response = await generateMessageResponse({\n            runtime: this.runtime,\n            context,\n            modelClass: ModelClass.SMALL,\n        });\n\n        response.source = \"discord\";\n\n        if (!response) {\n            console.error(\"No response from generateMessageResponse\");\n            return;\n        }\n\n        await this.runtime.databaseAdapter.log({\n            body: { message, context, response },\n            userId: userId,\n            roomId,\n            type: \"response\",\n        });\n\n        return response;\n    }\n\n    private async _shouldIgnore(message: Memory): Promise<boolean> {\n        // console.log(\"message: \", message);\n        elizaLogger.debug(\"message.content: \", message.content);\n        // if the message is 3 characters or less, ignore it\n        if ((message.content as Content).text.length < 3) {\n            return true;\n        }\n\n        const loseInterestWords = [\n            // telling the bot to stop talking\n            \"shut up\",\n            \"stop\",\n            \"dont talk\",\n            \"silence\",\n            \"stop talking\",\n            \"be quiet\",\n            \"hush\",\n            \"stfu\",\n            \"stupid bot\",\n            \"dumb bot\",\n\n            // offensive words\n            \"fuck\",\n            \"shit\",\n            \"damn\",\n            \"suck\",\n            \"dick\",\n            \"cock\",\n            \"sex\",\n            \"sexy\",\n        ];\n        if (\n            (message.content as Content).text.length < 50 &&\n            loseInterestWords.some((word) =>\n                (message.content as Content).text?.toLowerCase().includes(word)\n            )\n        ) {\n            return true;\n        }\n\n        const ignoreWords = [\"k\", \"ok\", \"bye\", \"lol\", \"nm\", \"uh\"];\n        if (\n            (message.content as Content).text?.length < 8 &&\n            ignoreWords.some((word) =>\n                (message.content as Content).text?.toLowerCase().includes(word)\n            )\n        ) {\n            return true;\n        }\n\n        return false;\n    }\n\n    async scanGuild(guild: Guild) {\n        const channels = (await guild.channels.fetch()).filter(\n            (channel) => channel?.type == ChannelType.GuildVoice\n        );\n        let chosenChannel: BaseGuildVoiceChannel | null = null;\n\n        for (const [, channel] of channels) {\n            const voiceChannel = channel as BaseGuildVoiceChannel;\n            if (\n                voiceChannel.members.size > 0 &&\n                (chosenChannel === null ||\n                    voiceChannel.members.size > chosenChannel.members.size)\n            ) {\n                chosenChannel = voiceChannel;\n            }\n        }\n\n        if (chosenChannel != null) {\n            this.joinChannel(chosenChannel);\n        }\n    }\n\n    async playAudioStream(userId: UUID, audioStream: Readable) {\n        const connection = this.connections.get(userId);\n        if (connection == null) {\n            console.log(`No connection for user ${userId}`);\n            return;\n        }\n        const audioPlayer = createAudioPlayer({\n            behaviors: {\n                noSubscriber: NoSubscriberBehavior.Pause,\n            },\n        });\n        connection.subscribe(audioPlayer);\n\n        const audioStartTime = Date.now();\n\n        const resource = createAudioResource(audioStream, {\n            inputType: StreamType.Arbitrary,\n        });\n        audioPlayer.play(resource);\n\n        audioPlayer.on(\"error\", (err: any) => {\n            console.log(`Audio player error: ${err}`);\n        });\n\n        audioPlayer.on(\n            \"stateChange\",\n            (oldState: any, newState: { status: string }) => {\n                if (newState.status == \"idle\") {\n                    const idleTime = Date.now();\n                    console.log(\n                        `Audio playback took: ${idleTime - audioStartTime}ms`\n                    );\n                }\n            }\n        );\n    }\n\n    async handleJoinChannelCommand(interaction: any) {\n        const channelId = interaction.options.get(\"channel\")?.value as string;\n        if (!channelId) {\n            await interaction.reply(\"Please provide a voice channel to join.\");\n            return;\n        }\n        const guild = interaction.guild;\n        if (!guild) {\n            return;\n        }\n        const voiceChannel = interaction.guild.channels.cache.find(\n            (channel: VoiceChannel) =>\n                channel.id === channelId &&\n                channel.type === ChannelType.GuildVoice\n        );\n\n        if (!voiceChannel) {\n            await interaction.reply(\"Voice channel not found!\");\n            return;\n        }\n\n        try {\n            this.joinChannel(voiceChannel as BaseGuildVoiceChannel);\n            await interaction.reply(\n                `Joined voice channel: ${voiceChannel.name}`\n            );\n        } catch (error) {\n            console.error(\"Error joining voice channel:\", error);\n            await interaction.reply(\"Failed to join the voice channel.\");\n        }\n    }\n\n    async handleLeaveChannelCommand(interaction: any) {\n        const connection = getVoiceConnection(interaction.guildId as any);\n\n        if (!connection) {\n            await interaction.reply(\"Not currently in a voice channel.\");\n            return;\n        }\n\n        try {\n            connection.destroy();\n            await interaction.reply(\"Left the voice channel.\");\n        } catch (error) {\n            console.error(\"Error leaving voice channel:\", error);\n            await interaction.reply(\"Failed to leave the voice channel.\");\n        }\n    }\n}\n","import { IAgentRuntime } from \"@ai16z/eliza\";\nimport { z } from \"zod\";\n\nexport const discordEnvSchema = z.object({\n    DISCORD_APPLICATION_ID: z\n        .string()\n        .min(1, \"Discord application ID is required\"),\n    DISCORD_API_TOKEN: z.string().min(1, \"Discord API token is required\"),\n});\n\nexport type DiscordConfig = z.infer<typeof discordEnvSchema>;\n\nexport async function validateDiscordConfig(\n    runtime: IAgentRuntime\n): Promise<DiscordConfig> {\n    try {\n        const config = {\n            DISCORD_APPLICATION_ID:\n                runtime.getSetting(\"DISCORD_APPLICATION_ID\") ||\n                process.env.DISCORD_APPLICATION_ID,\n            DISCORD_API_TOKEN:\n                runtime.getSetting(\"DISCORD_API_TOKEN\") ||\n                process.env.DISCORD_API_TOKEN,\n        };\n\n        return discordEnvSchema.parse(config);\n    } catch (error) {\n        if (error instanceof z.ZodError) {\n            const errorMessages = error.errors\n                .map((err) => `${err.path.join(\".\")}: ${err.message}`)\n                .join(\"\\n\");\n            throw new Error(\n                `Discord configuration validation failed:\\n${errorMessages}`\n            );\n        }\n        throw error;\n    }\n}\n"],"mappings":"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","names":["embeddingZeroVector","stringToUuid","elizaLogger","Client","EventEmitter","generateText","ModelClass","composeContext","parseJSONObjectFromText","ModelClass","generateText","composeContext","targetChannel","ChannelType","composeContext","generateText","trimTokens","models","parseJSONObjectFromText","ModelClass","summarizationTemplate","summarizeAction","composeContext","generateText","parseJSONObjectFromText","ModelClass","composeContext","generateText","ModelClass","parseJSONObjectFromText","attachment","composeContext","ModelClass","ServiceType","generateText","trimTokens","parseJSONObjectFromText","ChannelType","generateText","trimTokens","parseJSONObjectFromText","ModelClass","ServiceType","generateSummary","trimTokens","generateText","ModelClass","parseJSONObjectFromText","ChannelType","composeContext","content","ServiceType","memory","ChannelType","getVoiceConnection","ChannelType","ModelClass","ServiceType","composeContext","elizaLogger","embeddingZeroVector","generateMessageResponse","messageCompletionFooter","stringToUuid","getVoiceConnection","ChannelType","VoiceManager","content","roomId","EventEmitter","Client","VoiceManager","elizaLogger","stringToUuid","embeddingZeroVector"]}